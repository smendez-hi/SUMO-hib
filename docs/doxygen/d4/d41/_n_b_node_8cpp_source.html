<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SUMO - Simulation of Urban MObility: NBNode.cpp Source File</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="../../main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
      <li><a href="../../dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="../../files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="../../globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="../../dir_75b82e7e4a5feb05200b9ad7adf06257.html">home</a>&nbsp;&raquo;&nbsp;<a class="el" href="../../dir_46b8f36974b309f038ffc35aa047a32b.html">boni</a>&nbsp;&raquo;&nbsp;<a class="el" href="../../dir_52e5be8ca53cec2b5437a8ba83e8e4f0.html">Desktop</a>&nbsp;&raquo;&nbsp;<a class="el" href="../../dir_7de3ce0f65e0314f747915173f89e60e.html">DanielTouched</a>&nbsp;&raquo;&nbsp;<a class="el" href="../../dir_a0096e276045b3ff0719c75e0b3c59bf.html">sumo-0.14.0</a>&nbsp;&raquo;&nbsp;<a class="el" href="../../dir_e9b8d709919855cd07b0394009af2578.html">src</a>&nbsp;&raquo;&nbsp;<a class="el" href="../../dir_fef730b7af99b175e444dabf8b9377e8.html">netbuild</a>
  </div>
</div>
<div class="contents">
<h1>NBNode.cpp</h1><a href="../../d4/d41/_n_b_node_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************/</span>
<a name="l00010"></a>00010 <span class="comment">// The representation of a single node</span>
<a name="l00011"></a>00011 <span class="comment">/****************************************************************************/</span>
<a name="l00012"></a>00012 <span class="comment">// SUMO, Simulation of Urban MObility; see http://sumo.sourceforge.net/</span>
<a name="l00013"></a>00013 <span class="comment">// Copyright (C) 2001-2012 DLR (http://www.dlr.de/) and contributors</span>
<a name="l00014"></a>00014 <span class="comment">/****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">//   This file is part of SUMO.</span>
<a name="l00017"></a>00017 <span class="comment">//   SUMO is free software: you can redistribute it and/or modify</span>
<a name="l00018"></a>00018 <span class="comment">//   it under the terms of the GNU General Public License as published by</span>
<a name="l00019"></a>00019 <span class="comment">//   the Free Software Foundation, either version 3 of the License, or</span>
<a name="l00020"></a>00020 <span class="comment">//   (at your option) any later version.</span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 <span class="comment">/****************************************************************************/</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="comment">// ===========================================================================</span>
<a name="l00026"></a>00026 <span class="comment">// included modules</span>
<a name="l00027"></a>00027 <span class="comment">// ===========================================================================</span>
<a name="l00028"></a>00028 <span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span><span class="preprocessor">#include &lt;<a class="code" href="../../d3/d99/windows__config_8h.html">windows_config.h</a>&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#else</span>
<a name="l00031"></a>00031 <span class="preprocessor"></span><span class="preprocessor">#include &lt;<a class="code" href="../../db/d16/config_8h.html">config.h</a>&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#endif</span>
<a name="l00033"></a>00033 <span class="preprocessor"></span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;cassert&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;deque&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;set&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;cmath&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;iterator&gt;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;<a class="code" href="../../d7/db4/_util_exceptions_8h.html">utils/common/UtilExceptions.h</a>&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;<a class="code" href="../../de/dde/_string_utils_8h.html">utils/common/StringUtils.h</a>&gt;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;<a class="code" href="../../d3/d5c/_options_cont_8h.html">utils/options/OptionsCont.h</a>&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;<a class="code" href="../../d0/dee/_line_8h.html">utils/geom/Line.h</a>&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;<a class="code" href="../../d5/df0/_geom_helper_8h.html">utils/geom/GeomHelper.h</a>&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &lt;<a class="code" href="../../db/d07/bezier_8h.html">utils/geom/bezier.h</a>&gt;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &lt;<a class="code" href="../../d4/df7/_msg_handler_8h.html">utils/common/MsgHandler.h</a>&gt;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &lt;<a class="code" href="../../da/dbd/_std_defs_8h.html">utils/common/StdDefs.h</a>&gt;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &lt;<a class="code" href="../../d8/d08/_to_string_8h.html">utils/common/ToString.h</a>&gt;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &lt;<a class="code" href="../../d3/d6d/_geo_conv_helper_8h.html">utils/geom/GeoConvHelper.h</a>&gt;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include &lt;<a class="code" href="../../d1/d3f/_output_device_8h.html">utils/iodevices/OutputDevice.h</a>&gt;</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &lt;iomanip&gt;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &quot;<a class="code" href="../../d4/da0/_n_b_node_8h.html">NBNode.h</a>&quot;</span>
<a name="l00056"></a>00056 <span class="preprocessor">#include &quot;<a class="code" href="../../da/d09/_n_b_node_cont_8h.html">NBNodeCont.h</a>&quot;</span>
<a name="l00057"></a>00057 <span class="preprocessor">#include &quot;<a class="code" href="../../db/da4/_n_b_node_shape_computer_8h.html">NBNodeShapeComputer.h</a>&quot;</span>
<a name="l00058"></a>00058 <span class="preprocessor">#include &quot;<a class="code" href="../../d7/db4/_n_b_edge_cont_8h.html">NBEdgeCont.h</a>&quot;</span>
<a name="l00059"></a>00059 <span class="preprocessor">#include &quot;<a class="code" href="../../de/d1a/_n_b_type_cont_8h.html">NBTypeCont.h</a>&quot;</span>
<a name="l00060"></a>00060 <span class="preprocessor">#include &quot;<a class="code" href="../../da/d0c/_n_b_helpers_8h.html">NBHelpers.h</a>&quot;</span>
<a name="l00061"></a>00061 <span class="preprocessor">#include &quot;<a class="code" href="../../df/d03/_n_b_district_8h.html">NBDistrict.h</a>&quot;</span>
<a name="l00062"></a>00062 <span class="preprocessor">#include &quot;<a class="code" href="../../da/d7b/_n_b_cont_helper_8h.html">NBContHelper.h</a>&quot;</span>
<a name="l00063"></a>00063 <span class="preprocessor">#include &quot;<a class="code" href="../../d4/d32/_n_b_request_8h.html">NBRequest.h</a>&quot;</span>
<a name="l00064"></a>00064 <span class="preprocessor">#include &quot;<a class="code" href="../../d1/df8/_n_b_own_t_l_def_8h.html">NBOwnTLDef.h</a>&quot;</span>
<a name="l00065"></a>00065 <span class="preprocessor">#include &quot;<a class="code" href="../../d3/dd9/_n_b_traffic_light_logic_cont_8h.html">NBTrafficLightLogicCont.h</a>&quot;</span>
<a name="l00066"></a>00066 
<a name="l00067"></a>00067 <span class="preprocessor">#ifdef CHECK_MEMORY_LEAKS</span>
<a name="l00068"></a>00068 <span class="preprocessor"></span><span class="preprocessor">#include &lt;<a class="code" href="../../d7/d8d/debug__new_8h.html">foreign/nvwa/debug_new.h</a>&gt;</span>
<a name="l00069"></a>00069 <span class="preprocessor">#endif // CHECK_MEMORY_LEAKS</span>
<a name="l00070"></a>00070 <span class="preprocessor"></span>
<a name="l00071"></a>00071 
<a name="l00072"></a>00072 <span class="comment">// ===========================================================================</span>
<a name="l00073"></a>00073 <span class="comment">// static members</span>
<a name="l00074"></a>00074 <span class="comment">// ===========================================================================</span>
<a name="l00075"></a>00075 
<a name="l00076"></a>00076 <span class="comment">// ===========================================================================</span>
<a name="l00077"></a>00077 <span class="comment">// method definitions</span>
<a name="l00078"></a>00078 <span class="comment">// ===========================================================================</span>
<a name="l00079"></a>00079 <span class="comment">/* -------------------------------------------------------------------------</span>
<a name="l00080"></a>00080 <span class="comment"> * NBNode::ApproachingDivider-methods</span>
<a name="l00081"></a>00081 <span class="comment"> * ----------------------------------------------------------------------- */</span>
<a name="l00082"></a><a class="code" href="../../d5/dc7/class_n_b_node_1_1_approaching_divider.html#aca02a30699bceebf9bacfba465496f71">00082</a> <a class="code" href="../../d5/dc7/class_n_b_node_1_1_approaching_divider.html#aca02a30699bceebf9bacfba465496f71" title="Constructor.">NBNode::ApproachingDivider::ApproachingDivider</a>(
<a name="l00083"></a>00083     <a class="code" href="../../db/dde/_n_b_cont_8h.html#a7bbd80497f8b27f18697210825ec974a">EdgeVector</a>* approaching, <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* currentOutgoing) :
<a name="l00084"></a>00084     myApproaching(approaching), myCurrentOutgoing(currentOutgoing) {
<a name="l00085"></a>00085     <span class="comment">// check whether origin lanes have been given</span>
<a name="l00086"></a>00086     assert(<a class="code" href="../../d5/dc7/class_n_b_node_1_1_approaching_divider.html#ab4a29d3fff6d3a16455d122a06cb4dc1" title="The list of edges that approach the current edge.">myApproaching</a> != 0);
<a name="l00087"></a>00087 }
<a name="l00088"></a>00088 
<a name="l00089"></a>00089 
<a name="l00090"></a><a class="code" href="../../d5/dc7/class_n_b_node_1_1_approaching_divider.html#a346b1187c56fea51cbf55e3fc6caae59">00090</a> <a class="code" href="../../d5/dc7/class_n_b_node_1_1_approaching_divider.html#a346b1187c56fea51cbf55e3fc6caae59" title="Destructor.">NBNode::ApproachingDivider::~ApproachingDivider</a>() {}
<a name="l00091"></a>00091 
<a name="l00092"></a>00092 
<a name="l00093"></a>00093 <span class="keywordtype">void</span>
<a name="l00094"></a><a class="code" href="../../d5/dc7/class_n_b_node_1_1_approaching_divider.html#a53864cf2b10ee5174e69f6add6d37919">00094</a> <a class="code" href="../../d5/dc7/class_n_b_node_1_1_approaching_divider.html#a53864cf2b10ee5174e69f6add6d37919">NBNode::ApproachingDivider::execute</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> src, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dest) {
<a name="l00095"></a>00095     assert(<a class="code" href="../../d5/dc7/class_n_b_node_1_1_approaching_divider.html#ab4a29d3fff6d3a16455d122a06cb4dc1" title="The list of edges that approach the current edge.">myApproaching</a>-&gt;size() &gt; src);
<a name="l00096"></a>00096     <span class="comment">// get the origin edge</span>
<a name="l00097"></a>00097     <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* incomingEdge = (*myApproaching)[src];
<a name="l00098"></a>00098     <span class="keywordflow">if</span> (incomingEdge-&gt;getStep() == <a class="code" href="../../d7/d41/class_n_b_edge.html#a5f800e73a3f8ada2114981754cfbbc86a8b57edfa9193f5ee2ba1449232accec4" title="Lanes to lanes - relationships are computed; no recheck is necessary/wished.">NBEdge::LANES2LANES_DONE</a> || incomingEdge-&gt;getStep() == <a class="code" href="../../d7/d41/class_n_b_edge.html#a5f800e73a3f8ada2114981754cfbbc86adafb73f358e2e13e0c1b1e35b5081b03" title="Lanes to lanes - relationships are loaded; no recheck is necessary/wished.">NBEdge::LANES2LANES_USER</a>) {
<a name="l00099"></a>00099         <span class="keywordflow">return</span>;
<a name="l00100"></a>00100     }
<a name="l00101"></a>00101     std::vector&lt;int&gt; approachingLanes =
<a name="l00102"></a>00102         incomingEdge-&gt;getConnectionLanes(<a class="code" href="../../d5/dc7/class_n_b_node_1_1_approaching_divider.html#a82fd50a52af949ae8e0c7822fd68d014" title="The approached current edge.">myCurrentOutgoing</a>);
<a name="l00103"></a>00103     assert(approachingLanes.size() != 0);
<a name="l00104"></a>00104     std::deque&lt;int&gt; *approachedLanes = <a class="code" href="../../d5/dc7/class_n_b_node_1_1_approaching_divider.html#adcd46ed68659d0253913490be12ceb95">spread</a>(approachingLanes, dest);
<a name="l00105"></a>00105     assert(approachedLanes-&gt;size() &lt;= <a class="code" href="../../d5/dc7/class_n_b_node_1_1_approaching_divider.html#a82fd50a52af949ae8e0c7822fd68d014" title="The approached current edge.">myCurrentOutgoing</a>-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#aa6ed274bbffc247a43e91a8ec4b150a1" title="Returns the number of lanes.">getNumLanes</a>());
<a name="l00106"></a>00106     <span class="comment">// set lanes</span>
<a name="l00107"></a>00107     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; approachedLanes-&gt;size(); i++) {
<a name="l00108"></a>00108         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> approached = (*approachedLanes)[i];
<a name="l00109"></a>00109         assert(approachedLanes-&gt;size() &gt; i);
<a name="l00110"></a>00110         assert(approachingLanes.size() &gt; i);
<a name="l00111"></a>00111         incomingEdge-&gt;setConnection((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) approachingLanes[i], <a class="code" href="../../d5/dc7/class_n_b_node_1_1_approaching_divider.html#a82fd50a52af949ae8e0c7822fd68d014" title="The approached current edge.">myCurrentOutgoing</a>,
<a name="l00112"></a>00112                                     approached, <a class="code" href="../../d7/d41/class_n_b_edge.html#aa1576d07471ecc008d626cdbfb3302f2ae74f722fd0b9fd70b73c22135afd90f9" title="The connection was computed.">NBEdge::L2L_COMPUTED</a>);
<a name="l00113"></a>00113     }
<a name="l00114"></a>00114     <span class="keyword">delete</span> approachedLanes;
<a name="l00115"></a>00115 }
<a name="l00116"></a>00116 
<a name="l00117"></a>00117 
<a name="l00118"></a>00118 std::deque&lt;int&gt; *
<a name="l00119"></a><a class="code" href="../../d5/dc7/class_n_b_node_1_1_approaching_divider.html#adcd46ed68659d0253913490be12ceb95">00119</a> <a class="code" href="../../d5/dc7/class_n_b_node_1_1_approaching_divider.html#adcd46ed68659d0253913490be12ceb95">NBNode::ApproachingDivider::spread</a>(<span class="keyword">const</span> std::vector&lt;int&gt; &amp;approachingLanes,
<a name="l00120"></a>00120                                    <span class="keywordtype">int</span> dest)<span class="keyword"> const </span>{
<a name="l00121"></a>00121     std::deque&lt;int&gt; *ret = <span class="keyword">new</span> std::deque&lt;int&gt;();
<a name="l00122"></a>00122     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> noLanes = (<span class="keywordtype">unsigned</span> int) approachingLanes.size();
<a name="l00123"></a>00123     <span class="comment">// when only one lane is approached, we check, whether the SUMOReal-value</span>
<a name="l00124"></a>00124     <span class="comment">//  is assigned more to the left or right lane</span>
<a name="l00125"></a>00125     <span class="keywordflow">if</span> (noLanes == 1) {
<a name="l00126"></a>00126         ret-&gt;push_back(dest);
<a name="l00127"></a>00127         <span class="keywordflow">return</span> ret;
<a name="l00128"></a>00128     }
<a name="l00129"></a>00129 
<a name="l00130"></a>00130     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> noOutgoingLanes = <a class="code" href="../../d5/dc7/class_n_b_node_1_1_approaching_divider.html#a82fd50a52af949ae8e0c7822fd68d014" title="The approached current edge.">myCurrentOutgoing</a>-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#aa6ed274bbffc247a43e91a8ec4b150a1" title="Returns the number of lanes.">getNumLanes</a>();
<a name="l00131"></a>00131     <span class="comment">//</span>
<a name="l00132"></a>00132     ret-&gt;push_back(dest);
<a name="l00133"></a>00133     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> noSet = 1;
<a name="l00134"></a>00134     <span class="keywordtype">int</span> roffset = 1;
<a name="l00135"></a>00135     <span class="keywordtype">int</span> loffset = 1;
<a name="l00136"></a>00136     <span class="keywordflow">while</span> (noSet &lt; noLanes) {
<a name="l00137"></a>00137         <span class="comment">// It may be possible, that there are not enough lanes the source</span>
<a name="l00138"></a>00138         <span class="comment">//  lanes may be divided on</span>
<a name="l00139"></a>00139         <span class="comment">//  In this case, they remain unset</span>
<a name="l00140"></a>00140         <span class="comment">//  !!! this is only a hack. It is possible, that this yields in</span>
<a name="l00141"></a>00141         <span class="comment">//   uncommon divisions</span>
<a name="l00142"></a>00142         <span class="keywordflow">if</span> (noOutgoingLanes == noSet) {
<a name="l00143"></a>00143             <span class="keywordflow">return</span> ret;
<a name="l00144"></a>00144         }
<a name="l00145"></a>00145 
<a name="l00146"></a>00146         <span class="comment">// as due to the conversion of SUMOReal-&gt;uint the numbers will be lower</span>
<a name="l00147"></a>00147         <span class="comment">//  than they should be, we try to append to the left side first</span>
<a name="l00148"></a>00148         <span class="comment">//</span>
<a name="l00149"></a>00149         <span class="comment">// check whether the left boundary of the approached street has</span>
<a name="l00150"></a>00150         <span class="comment">//  been overridden; if so, move all lanes to the right</span>
<a name="l00151"></a>00151         <span class="keywordflow">if</span> (dest + loffset &gt;= static_cast&lt;int&gt;(noOutgoingLanes)) {
<a name="l00152"></a>00152             loffset -= 1;
<a name="l00153"></a>00153             roffset += 1;
<a name="l00154"></a>00154             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; ret-&gt;size(); i++) {
<a name="l00155"></a>00155                 (*ret)[i] = (*ret)[i] - 1;
<a name="l00156"></a>00156             }
<a name="l00157"></a>00157         }
<a name="l00158"></a>00158         <span class="comment">// append the next lane to the left of all edges</span>
<a name="l00159"></a>00159         <span class="comment">//  increase the position (destination edge)</span>
<a name="l00160"></a>00160         ret-&gt;push_back(dest + loffset);
<a name="l00161"></a>00161         noSet++;
<a name="l00162"></a>00162         loffset += 1;
<a name="l00163"></a>00163 
<a name="l00164"></a>00164         <span class="comment">// as above</span>
<a name="l00165"></a>00165         <span class="keywordflow">if</span> (noOutgoingLanes == noSet) {
<a name="l00166"></a>00166             <span class="keywordflow">return</span> ret;
<a name="l00167"></a>00167         }
<a name="l00168"></a>00168 
<a name="l00169"></a>00169         <span class="comment">// now we try to append the next lane to the right side, when needed</span>
<a name="l00170"></a>00170         <span class="keywordflow">if</span> (noSet &lt; noLanes) {
<a name="l00171"></a>00171             <span class="comment">// check whether the right boundary of the approached street has</span>
<a name="l00172"></a>00172             <span class="comment">//  been overridden; if so, move all lanes to the right</span>
<a name="l00173"></a>00173             <span class="keywordflow">if</span> (dest &lt; roffset) {
<a name="l00174"></a>00174                 loffset += 1;
<a name="l00175"></a>00175                 roffset -= 1;
<a name="l00176"></a>00176                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; ret-&gt;size(); i++) {
<a name="l00177"></a>00177                     (*ret)[i] = (*ret)[i] + 1;
<a name="l00178"></a>00178                 }
<a name="l00179"></a>00179             }
<a name="l00180"></a>00180             ret-&gt;push_front(dest - roffset);
<a name="l00181"></a>00181             noSet++;
<a name="l00182"></a>00182             roffset += 1;
<a name="l00183"></a>00183         }
<a name="l00184"></a>00184     }
<a name="l00185"></a>00185     <span class="keywordflow">return</span> ret;
<a name="l00186"></a>00186 }
<a name="l00187"></a>00187 
<a name="l00188"></a>00188 
<a name="l00189"></a>00189 
<a name="l00190"></a>00190 
<a name="l00191"></a>00191 <span class="comment">/* -------------------------------------------------------------------------</span>
<a name="l00192"></a>00192 <span class="comment"> * NBNode-methods</span>
<a name="l00193"></a>00193 <span class="comment"> * ----------------------------------------------------------------------- */</span>
<a name="l00194"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a99792722464f698564b94a76927ff4b4">00194</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a99792722464f698564b94a76927ff4b4" title="Constructor.">NBNode::NBNode</a>(<span class="keyword">const</span> std::string&amp; <span class="keywordtype">id</span>, <span class="keyword">const</span> <a class="code" href="../../d7/d3b/class_position.html" title="A point in 2D or 3D with translation and scaling methods.">Position</a>&amp; position) :
<a name="l00195"></a>00195     <a class="code" href="../../d5/dbf/class_named.html" title="Base class for objects which do have an id.">Named</a>(<a class="code" href="../../d3/d93/class_string_utils.html" title="Some static methods for string processing.">StringUtils</a>::convertUmlaute(id)),
<a name="l00196"></a>00196     <a class="code" href="../../d3/dd1/class_n_b_node.html#aa2428b3f739977ceb4ac659eb93e4234" title="The position the node lies at.">myPosition</a>(position),
<a name="l00197"></a>00197     <a class="code" href="../../d3/dd1/class_n_b_node.html#a4547c21e970c3ca1cdf98d20c347ffdc" title="The type of the junction.">myType</a>(<a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#ab28dfb39f850f0859f8e28940b7ff60ba83f3842f496fa9a36448211498a4f4f4">NODETYPE_UNKNOWN</a>), <a class="code" href="../../d3/dd1/class_n_b_node.html#ab5565e3d9d3aaa3d6520acfb95f497c0" title="The district the node is the centre of.">myDistrict</a>(0), <a class="code" href="../../d3/dd1/class_n_b_node.html#a4db054c358db8eb749514219368f3308">myRequest</a>(0)
<a name="l00198"></a>00198 { }
<a name="l00199"></a>00199 
<a name="l00200"></a>00200 
<a name="l00201"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a299f8a4f460c27c8212b78bd74b931cd">00201</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a99792722464f698564b94a76927ff4b4" title="Constructor.">NBNode::NBNode</a>(<span class="keyword">const</span> std::string&amp; <span class="keywordtype">id</span>, <span class="keyword">const</span> <a class="code" href="../../d7/d3b/class_position.html" title="A point in 2D or 3D with translation and scaling methods.">Position</a>&amp; position,
<a name="l00202"></a>00202                <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#ab28dfb39f850f0859f8e28940b7ff60b" title="Numbers representing special SUMO-XML-attribute values for representing node- (junction-)...">SumoXMLNodeType</a> type) :
<a name="l00203"></a>00203     <a class="code" href="../../d5/dbf/class_named.html" title="Base class for objects which do have an id.">Named</a>(<a class="code" href="../../d3/d93/class_string_utils.html" title="Some static methods for string processing.">StringUtils</a>::convertUmlaute(id)),
<a name="l00204"></a>00204     myPosition(position),
<a name="l00205"></a>00205     myType(type), myDistrict(0), myRequest(0)
<a name="l00206"></a>00206 { }
<a name="l00207"></a>00207 
<a name="l00208"></a>00208 
<a name="l00209"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a30bf3153141f3acc031ca9c998f0812a">00209</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a99792722464f698564b94a76927ff4b4" title="Constructor.">NBNode::NBNode</a>(<span class="keyword">const</span> std::string&amp; <span class="keywordtype">id</span>, <span class="keyword">const</span> <a class="code" href="../../d7/d3b/class_position.html" title="A point in 2D or 3D with translation and scaling methods.">Position</a>&amp; position, <a class="code" href="../../d7/d91/class_n_b_district.html" title="A class representing a single district.">NBDistrict</a>* district) :
<a name="l00210"></a>00210     <a class="code" href="../../d5/dbf/class_named.html" title="Base class for objects which do have an id.">Named</a>(<a class="code" href="../../d3/d93/class_string_utils.html" title="Some static methods for string processing.">StringUtils</a>::convertUmlaute(id)),
<a name="l00211"></a>00211     myPosition(position),
<a name="l00212"></a>00212     myType(<a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#ab28dfb39f850f0859f8e28940b7ff60bad47669f635d721ff836d08b870a9efc4">NODETYPE_DISTRICT</a>), myDistrict(district), myRequest(0)
<a name="l00213"></a>00213 { }
<a name="l00214"></a>00214 
<a name="l00215"></a>00215 
<a name="l00216"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#aed01c9a7a10b6d76a1d6d38057419267">00216</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#aed01c9a7a10b6d76a1d6d38057419267" title="Destructor.">NBNode::~NBNode</a>() {
<a name="l00217"></a>00217     <span class="keyword">delete</span> <a class="code" href="../../d3/dd1/class_n_b_node.html#a4db054c358db8eb749514219368f3308">myRequest</a>;
<a name="l00218"></a>00218 }
<a name="l00219"></a>00219 
<a name="l00220"></a>00220 
<a name="l00221"></a>00221 <span class="keywordtype">void</span>
<a name="l00222"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a24ac2575beb01c1308d1b46068d8f9f4">00222</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a24ac2575beb01c1308d1b46068d8f9f4" title="Resets initial values.">NBNode::reinit</a>(<span class="keyword">const</span> <a class="code" href="../../d7/d3b/class_position.html" title="A point in 2D or 3D with translation and scaling methods.">Position</a>&amp; position, <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#ab28dfb39f850f0859f8e28940b7ff60b" title="Numbers representing special SUMO-XML-attribute values for representing node- (junction-)...">SumoXMLNodeType</a> type,
<a name="l00223"></a>00223                <span class="keywordtype">bool</span> updateEdgeGeometries) {
<a name="l00224"></a>00224     <a class="code" href="../../d3/dd1/class_n_b_node.html#aa2428b3f739977ceb4ac659eb93e4234" title="The position the node lies at.">myPosition</a> = position;
<a name="l00225"></a>00225     <span class="comment">// patch type</span>
<a name="l00226"></a>00226     <a class="code" href="../../d3/dd1/class_n_b_node.html#a4547c21e970c3ca1cdf98d20c347ffdc" title="The type of the junction.">myType</a> = type;
<a name="l00227"></a>00227     <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#a4547c21e970c3ca1cdf98d20c347ffdc" title="The type of the junction.">myType</a> != <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#ab28dfb39f850f0859f8e28940b7ff60bae8545f9299fc30cd0253e6dc207946c4">NODETYPE_TRAFFIC_LIGHT</a>) {
<a name="l00228"></a>00228         <a class="code" href="../../d3/dd1/class_n_b_node.html#a94eecc6847719ab5672cbc6ab51dc430" title="Removes all references to traffic lights that control this tls.">removeTrafficLights</a>();
<a name="l00229"></a>00229     }
<a name="l00230"></a>00230     <span class="keywordflow">if</span> (updateEdgeGeometries) {
<a name="l00231"></a>00231         <span class="keywordflow">for</span> (EdgeVector::iterator i = <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.begin(); i != <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.end(); i++) {
<a name="l00232"></a>00232             <a class="code" href="../../da/d56/class_position_vector.html" title="A list of 2D-positions.">PositionVector</a> geom = (*i)-&gt;getGeometry();
<a name="l00233"></a>00233             geom[-1] = <a class="code" href="../../d3/dd1/class_n_b_node.html#aa2428b3f739977ceb4ac659eb93e4234" title="The position the node lies at.">myPosition</a>;
<a name="l00234"></a>00234             (*i)-&gt;setGeometry(geom);
<a name="l00235"></a>00235         }
<a name="l00236"></a>00236         <span class="keywordflow">for</span> (EdgeVector::iterator i = <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.begin(); i != <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.end(); i++) {
<a name="l00237"></a>00237             <a class="code" href="../../da/d56/class_position_vector.html" title="A list of 2D-positions.">PositionVector</a> geom = (*i)-&gt;getGeometry();
<a name="l00238"></a>00238             geom[0] = <a class="code" href="../../d3/dd1/class_n_b_node.html#aa2428b3f739977ceb4ac659eb93e4234" title="The position the node lies at.">myPosition</a>;
<a name="l00239"></a>00239             (*i)-&gt;setGeometry(geom);
<a name="l00240"></a>00240         }
<a name="l00241"></a>00241     }
<a name="l00242"></a>00242 }
<a name="l00243"></a>00243 
<a name="l00244"></a>00244 
<a name="l00245"></a>00245 
<a name="l00246"></a>00246 <span class="comment">// -----------  Applying offset</span>
<a name="l00247"></a>00247 <span class="keywordtype">void</span>
<a name="l00248"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a1113c4bcda86f872f3db752ac9f54ce5">00248</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a1113c4bcda86f872f3db752ac9f54ce5" title="Applies an offset to the node.">NBNode::reshiftPosition</a>(<a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a> xoff, <a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a> yoff) {
<a name="l00249"></a>00249     <a class="code" href="../../d3/dd1/class_n_b_node.html#aa2428b3f739977ceb4ac659eb93e4234" title="The position the node lies at.">myPosition</a>.<a class="code" href="../../d7/d3b/class_position.html#a5a797c71945efb11f9ad4c7bacf4e7a0">reshiftRotate</a>(xoff, yoff, 0);
<a name="l00250"></a>00250     <a class="code" href="../../d3/dd1/class_n_b_node.html#ae698ead9f7c0e5205646ebec2839c8bc" title="the (outer) shape of the junction">myPoly</a>.<a class="code" href="../../da/d56/class_position_vector.html#a1ad1e7640d5d1612539852a0b9a3d4d4">reshiftRotate</a>(xoff, yoff, 0);
<a name="l00251"></a>00251 }
<a name="l00252"></a>00252 
<a name="l00253"></a>00253 
<a name="l00254"></a>00254 <span class="comment">// -----------  Methods for dealing with assigned traffic lights</span>
<a name="l00255"></a>00255 <span class="keywordtype">void</span>
<a name="l00256"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#af8783fb92a459a0a21ac57b95d24b6ea">00256</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#af8783fb92a459a0a21ac57b95d24b6ea" title="Adds a traffic light to the list of traffic lights that control this node.">NBNode::addTrafficLight</a>(<a class="code" href="../../d3/de8/class_n_b_traffic_light_definition.html" title="The base class for traffic light logic definitions.">NBTrafficLightDefinition</a>* tlDef) {
<a name="l00257"></a>00257     <a class="code" href="../../d3/dd1/class_n_b_node.html#a7f77619f8b2c286410247b7dd4b4a23a">myTrafficLights</a>.insert(tlDef);
<a name="l00258"></a>00258     <a class="code" href="../../d3/dd1/class_n_b_node.html#a4547c21e970c3ca1cdf98d20c347ffdc" title="The type of the junction.">myType</a> = <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#ab28dfb39f850f0859f8e28940b7ff60bae8545f9299fc30cd0253e6dc207946c4">NODETYPE_TRAFFIC_LIGHT</a>;
<a name="l00259"></a>00259 }
<a name="l00260"></a>00260 
<a name="l00261"></a>00261 
<a name="l00262"></a>00262 <span class="keywordtype">void</span>
<a name="l00263"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#ac09e0c61463814cf52ad6615880b1b20">00263</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#ac09e0c61463814cf52ad6615880b1b20" title="Removes the given traffic light from this node.">NBNode::removeTrafficLight</a>(<a class="code" href="../../d3/de8/class_n_b_traffic_light_definition.html" title="The base class for traffic light logic definitions.">NBTrafficLightDefinition</a>* tlDef) {
<a name="l00264"></a>00264     tlDef-&gt;<a class="code" href="../../d3/de8/class_n_b_traffic_light_definition.html#a37a39df2826d9a223ca7f899efe17291" title="Removes the given node from the list of controlled nodes.">removeNode</a>(<span class="keyword">this</span>);
<a name="l00265"></a>00265     <a class="code" href="../../d3/dd1/class_n_b_node.html#a7f77619f8b2c286410247b7dd4b4a23a">myTrafficLights</a>.erase(tlDef);
<a name="l00266"></a>00266 }
<a name="l00267"></a>00267 
<a name="l00268"></a>00268 
<a name="l00269"></a>00269 <span class="keywordtype">void</span>
<a name="l00270"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a94eecc6847719ab5672cbc6ab51dc430">00270</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a94eecc6847719ab5672cbc6ab51dc430" title="Removes all references to traffic lights that control this tls.">NBNode::removeTrafficLights</a>() {
<a name="l00271"></a>00271     std::set&lt;NBTrafficLightDefinition*&gt; trafficLights = <a class="code" href="../../d3/dd1/class_n_b_node.html#a7f77619f8b2c286410247b7dd4b4a23a">myTrafficLights</a>; <span class="comment">// make a copy because we will modify the original</span>
<a name="l00272"></a>00272     <span class="keywordflow">for</span> (std::set&lt;NBTrafficLightDefinition*&gt;::const_iterator i = trafficLights.begin(); i != trafficLights.end(); ++i) {
<a name="l00273"></a>00273         <a class="code" href="../../d3/dd1/class_n_b_node.html#ac09e0c61463814cf52ad6615880b1b20" title="Removes the given traffic light from this node.">removeTrafficLight</a>(*i);
<a name="l00274"></a>00274     }
<a name="l00275"></a>00275 }
<a name="l00276"></a>00276 
<a name="l00277"></a>00277 
<a name="l00278"></a>00278 <span class="keywordtype">bool</span>
<a name="l00279"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a604e4bd1bb4e544855a9f05894ce1f18">00279</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a604e4bd1bb4e544855a9f05894ce1f18" title="Returns whether this node is controlled by a tls that spans over more than one node...">NBNode::isJoinedTLSControlled</a>()<span class="keyword"> const </span>{
<a name="l00280"></a>00280     <span class="keywordflow">if</span> (!<a class="code" href="../../d3/dd1/class_n_b_node.html#aefa16e066da9a4ca84252f0ee5e32a8a" title="Returns whether this node is controlled by any tls.">isTLControlled</a>()) {
<a name="l00281"></a>00281         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00282"></a>00282     }
<a name="l00283"></a>00283     <span class="keywordflow">for</span> (std::set&lt;NBTrafficLightDefinition*&gt;::const_iterator i = <a class="code" href="../../d3/dd1/class_n_b_node.html#a7f77619f8b2c286410247b7dd4b4a23a">myTrafficLights</a>.begin(); i != <a class="code" href="../../d3/dd1/class_n_b_node.html#a7f77619f8b2c286410247b7dd4b4a23a">myTrafficLights</a>.end(); ++i) {
<a name="l00284"></a>00284         <span class="keywordflow">if</span> ((*i)-&gt;getID().find(<span class="stringliteral">&quot;joined&quot;</span>) == 0) {
<a name="l00285"></a>00285             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00286"></a>00286         }
<a name="l00287"></a>00287     }
<a name="l00288"></a>00288     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00289"></a>00289 }
<a name="l00290"></a>00290 
<a name="l00291"></a>00291 
<a name="l00292"></a>00292 <span class="comment">// ----------- Prunning the input</span>
<a name="l00293"></a>00293 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00294"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#aae43b05cc28af8dc74c5c8eb7b9e87b4">00294</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#aae43b05cc28af8dc74c5c8eb7b9e87b4" title="Removes edges which are both incoming and outgoing into this node.">NBNode::removeSelfLoops</a>(<a class="code" href="../../d3/d1f/class_n_b_district_cont.html" title="A container for districts.">NBDistrictCont</a>&amp; dc, <a class="code" href="../../da/ded/class_n_b_edge_cont.html" title="Storage for edges, including some functionality operating on multiple edges.">NBEdgeCont</a>&amp; ec, <a class="code" href="../../d9/d5e/class_n_b_traffic_light_logic_cont.html" title="A container for traffic light definitions and built programs.">NBTrafficLightLogicCont</a>&amp; tc) {
<a name="l00295"></a>00295     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ret = 0;
<a name="l00296"></a>00296     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = 0;
<a name="l00297"></a>00297     EdgeVector::const_iterator j = <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.begin();
<a name="l00298"></a>00298     <span class="keywordflow">while</span> (j != <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.end()) {
<a name="l00299"></a>00299         <span class="comment">// skip edges which are only incoming and not outgoing</span>
<a name="l00300"></a>00300         <span class="keywordflow">if</span> (find(<a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.begin(), <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.end(), *j) == <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.end()) {
<a name="l00301"></a>00301             ++j;
<a name="l00302"></a>00302             ++pos;
<a name="l00303"></a>00303             <span class="keywordflow">continue</span>;
<a name="l00304"></a>00304         }
<a name="l00305"></a>00305         <span class="comment">// an edge with both its origin and destination being the current</span>
<a name="l00306"></a>00306         <span class="comment">//  node should be removed</span>
<a name="l00307"></a>00307         <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* dummy = *j;
<a name="l00308"></a>00308         <a class="code" href="../../d4/df7/_msg_handler_8h.html#a6875e463bd2d24f027eba135e7a5fdfa">WRITE_WARNING</a>(<span class="stringliteral">&quot; Removing self-looping edge &#39;&quot;</span> + dummy-&gt;<a class="code" href="../../d5/dbf/class_named.html#a20fd12b55c213fd79eae9fdd47b14eb1" title="Returns the id.">getID</a>() + <span class="stringliteral">&quot;&#39;&quot;</span>);
<a name="l00309"></a>00309         <span class="comment">// get the list of incoming edges connected to the self-loop</span>
<a name="l00310"></a>00310         <a class="code" href="../../db/dde/_n_b_cont_8h.html#a7bbd80497f8b27f18697210825ec974a">EdgeVector</a> incomingConnected;
<a name="l00311"></a>00311         <span class="keywordflow">for</span> (EdgeVector::const_iterator i = <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.begin(); i != <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.end(); i++) {
<a name="l00312"></a>00312             <span class="keywordflow">if</span> ((*i)-&gt;isConnectedTo(dummy) &amp;&amp; *i != dummy) {
<a name="l00313"></a>00313                 incomingConnected.push_back(*i);
<a name="l00314"></a>00314             }
<a name="l00315"></a>00315         }
<a name="l00316"></a>00316         <span class="comment">// get the list of outgoing edges connected to the self-loop</span>
<a name="l00317"></a>00317         <a class="code" href="../../db/dde/_n_b_cont_8h.html#a7bbd80497f8b27f18697210825ec974a">EdgeVector</a> outgoingConnected;
<a name="l00318"></a>00318         <span class="keywordflow">for</span> (EdgeVector::const_iterator i = <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.begin(); i != <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.end(); i++) {
<a name="l00319"></a>00319             <span class="keywordflow">if</span> (dummy-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#ae4d14ddb7daff3570417f1f7941eebf1" title="Returns the information whethe a connection to the given edge has been added (or...">isConnectedTo</a>(*i) &amp;&amp; *i != dummy) {
<a name="l00320"></a>00320                 outgoingConnected.push_back(*i);
<a name="l00321"></a>00321             }
<a name="l00322"></a>00322         }
<a name="l00323"></a>00323         <span class="comment">// let the self-loop remap its connections</span>
<a name="l00324"></a>00324         dummy-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#a60bb180307602953945435a54ccd8769" title="Remaps the connection in a way that allows the removal of it.">remapConnections</a>(incomingConnected);
<a name="l00325"></a>00325         <a class="code" href="../../d3/dd1/class_n_b_node.html#a446a4a767d46d16aaa463c74943ccb7a">remapRemoved</a>(tc, dummy, incomingConnected, outgoingConnected);
<a name="l00326"></a>00326         <span class="comment">// delete the self-loop</span>
<a name="l00327"></a>00327         ec.<a class="code" href="../../da/ded/class_n_b_edge_cont.html#a40e00f566d26a3ec46c7ee5be1f1e582" title="Removes the given edge from the container (deleting it).">erase</a>(dc, dummy);
<a name="l00328"></a>00328         j = <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.begin() + pos;
<a name="l00329"></a>00329         ++ret;
<a name="l00330"></a>00330     }
<a name="l00331"></a>00331     <span class="keywordflow">return</span> ret;
<a name="l00332"></a>00332 }
<a name="l00333"></a>00333 
<a name="l00334"></a>00334 
<a name="l00335"></a>00335 <span class="comment">// -----------</span>
<a name="l00336"></a>00336 <span class="keywordtype">void</span>
<a name="l00337"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a013dd604b0021909db2499e7cb24a553">00337</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a013dd604b0021909db2499e7cb24a553" title="adds an incoming edge">NBNode::addIncomingEdge</a>(<a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* edge) {
<a name="l00338"></a>00338     assert(edge != 0);
<a name="l00339"></a>00339     <span class="keywordflow">if</span> (find(<a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.begin(), <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.end(), edge) == <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.end()) {
<a name="l00340"></a>00340         <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.push_back(edge);
<a name="l00341"></a>00341         <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.push_back(edge);
<a name="l00342"></a>00342     }
<a name="l00343"></a>00343 }
<a name="l00344"></a>00344 
<a name="l00345"></a>00345 
<a name="l00346"></a>00346 <span class="keywordtype">void</span>
<a name="l00347"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#aac797fc3aea0d64b4a440e26f23691f0">00347</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#aac797fc3aea0d64b4a440e26f23691f0" title="adds an outgoing edge">NBNode::addOutgoingEdge</a>(<a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* edge) {
<a name="l00348"></a>00348     assert(edge != 0);
<a name="l00349"></a>00349     <span class="keywordflow">if</span> (find(<a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.begin(), <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.end(), edge) == <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.end()) {
<a name="l00350"></a>00350         <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.push_back(edge);
<a name="l00351"></a>00351         <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.push_back(edge);
<a name="l00352"></a>00352     }
<a name="l00353"></a>00353 }
<a name="l00354"></a>00354 
<a name="l00355"></a>00355 
<a name="l00356"></a>00356 <span class="keywordtype">bool</span>
<a name="l00357"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a129eb304910fd02352850a7b16df67d8">00357</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a129eb304910fd02352850a7b16df67d8">NBNode::swapWhenReversed</a>(<span class="keywordtype">bool</span> leftHand,
<a name="l00358"></a>00358                          <span class="keyword">const</span> EdgeVector::iterator&amp; i1,
<a name="l00359"></a>00359                          <span class="keyword">const</span> EdgeVector::iterator&amp; i2) {
<a name="l00360"></a>00360     <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* e1 = *i1;
<a name="l00361"></a>00361     <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* e2 = *i2;
<a name="l00362"></a>00362     <span class="keywordflow">if</span> (leftHand) {
<a name="l00363"></a>00363         <span class="keywordflow">if</span> (e1-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#a47de8fb27ded13ba7886218da6b9a60f" title="Returns the destination node of the edge.">getToNode</a>() == <span class="keyword">this</span> &amp;&amp; e1-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#a524ad2f68eea68fb66ae185949a3a379" title="Returns whether the given edge is the opposite direction to this edge.">isTurningDirectionAt</a>(<span class="keyword">this</span>, e2)) {
<a name="l00364"></a>00364             std::swap(*i1, *i2);
<a name="l00365"></a>00365             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00366"></a>00366         }
<a name="l00367"></a>00367     } <span class="keywordflow">else</span> {
<a name="l00368"></a>00368         <span class="keywordflow">if</span> (e2-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#a47de8fb27ded13ba7886218da6b9a60f" title="Returns the destination node of the edge.">getToNode</a>() == <span class="keyword">this</span> &amp;&amp; e2-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#a524ad2f68eea68fb66ae185949a3a379" title="Returns whether the given edge is the opposite direction to this edge.">isTurningDirectionAt</a>(<span class="keyword">this</span>, e1)) {
<a name="l00369"></a>00369             std::swap(*i1, *i2);
<a name="l00370"></a>00370             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00371"></a>00371         }
<a name="l00372"></a>00372     }
<a name="l00373"></a>00373     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00374"></a>00374 }
<a name="l00375"></a>00375 
<a name="l00376"></a>00376 <span class="keywordtype">void</span>
<a name="l00377"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#af30456a3d70e6ae3f24c1d3d275cfb94">00377</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#af30456a3d70e6ae3f24c1d3d275cfb94">NBNode::computePriorities</a>() {
<a name="l00378"></a>00378     <span class="comment">// reset all priorities</span>
<a name="l00379"></a>00379     EdgeVector::iterator i;
<a name="l00380"></a>00380     <span class="comment">// check if the junction is not a real junction</span>
<a name="l00381"></a>00381     <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.size() == 1 &amp;&amp; <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.size() == 1) {
<a name="l00382"></a>00382         <span class="keywordflow">for</span> (i = <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.begin(); i != <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.end(); i++) {
<a name="l00383"></a>00383             (*i)-&gt;setJunctionPriority(<span class="keyword">this</span>, 1);
<a name="l00384"></a>00384         }
<a name="l00385"></a>00385         <span class="keywordflow">return</span>;
<a name="l00386"></a>00386     }
<a name="l00387"></a>00387     <span class="comment">// preset all junction&#39;s edge priorities to zero</span>
<a name="l00388"></a>00388     <span class="keywordflow">for</span> (i = <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.begin(); i != <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.end(); i++) {
<a name="l00389"></a>00389         (*i)-&gt;setJunctionPriority(<span class="keyword">this</span>, 0);
<a name="l00390"></a>00390     }
<a name="l00391"></a>00391     <span class="comment">// compute the priorities on junction when needed</span>
<a name="l00392"></a>00392     <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#a4547c21e970c3ca1cdf98d20c347ffdc" title="The type of the junction.">myType</a> != <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#ab28dfb39f850f0859f8e28940b7ff60ba3ab04e8411b56a12f844bd542e004e73">NODETYPE_RIGHT_BEFORE_LEFT</a>) {
<a name="l00393"></a>00393         <a class="code" href="../../d3/dd1/class_n_b_node.html#ac93daf7fc4c95c43036d2c80192e7d48" title="sets the priorites in case of a priority junction">setPriorityJunctionPriorities</a>();
<a name="l00394"></a>00394     }
<a name="l00395"></a>00395 }
<a name="l00396"></a>00396 
<a name="l00397"></a>00397 
<a name="l00398"></a>00398 <span class="keywordtype">void</span>
<a name="l00399"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#af656a572acb0843831ff5df97f5f7bf2">00399</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#af656a572acb0843831ff5df97f5f7bf2">NBNode::computeType</a>(<span class="keyword">const</span> <a class="code" href="../../db/d57/class_n_b_type_cont.html" title="A storage for available types of edges.">NBTypeCont</a>&amp; tc) {
<a name="l00400"></a>00400     <span class="comment">// the type may already be set from the data</span>
<a name="l00401"></a>00401     <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#a4547c21e970c3ca1cdf98d20c347ffdc" title="The type of the junction.">myType</a> != <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#ab28dfb39f850f0859f8e28940b7ff60ba83f3842f496fa9a36448211498a4f4f4">NODETYPE_UNKNOWN</a>) {
<a name="l00402"></a>00402         <span class="keywordflow">return</span>;
<a name="l00403"></a>00403     }
<a name="l00404"></a>00404     <span class="comment">// check whether the junction is not a real junction</span>
<a name="l00405"></a>00405     <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.size() == 1) {
<a name="l00406"></a>00406         <a class="code" href="../../d3/dd1/class_n_b_node.html#a4547c21e970c3ca1cdf98d20c347ffdc" title="The type of the junction.">myType</a> = <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#ab28dfb39f850f0859f8e28940b7ff60bae99c128b7557b84957226cd8cda11f07">NODETYPE_PRIORITY_JUNCTION</a>;
<a name="l00407"></a>00407         <span class="keywordflow">return</span>;
<a name="l00408"></a>00408     }
<a name="l00409"></a>00409     <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#ad7e5a6a250bc116265c8c2898a83c247">isSimpleContinuation</a>()) {
<a name="l00410"></a>00410         <a class="code" href="../../d3/dd1/class_n_b_node.html#a4547c21e970c3ca1cdf98d20c347ffdc" title="The type of the junction.">myType</a> = <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#ab28dfb39f850f0859f8e28940b7ff60bae99c128b7557b84957226cd8cda11f07">NODETYPE_PRIORITY_JUNCTION</a>;
<a name="l00411"></a>00411         <span class="keywordflow">return</span>;
<a name="l00412"></a>00412     }
<a name="l00413"></a>00413     <span class="comment">// choose the uppermost type as default</span>
<a name="l00414"></a>00414     <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#ab28dfb39f850f0859f8e28940b7ff60b" title="Numbers representing special SUMO-XML-attribute values for representing node- (junction-)...">SumoXMLNodeType</a> type = <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#ab28dfb39f850f0859f8e28940b7ff60ba3ab04e8411b56a12f844bd542e004e73">NODETYPE_RIGHT_BEFORE_LEFT</a>;
<a name="l00415"></a>00415     <span class="comment">// determine the type</span>
<a name="l00416"></a>00416     <span class="keywordflow">for</span> (EdgeVector::const_iterator i = <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.begin(); i != <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.end(); i++) {
<a name="l00417"></a>00417         <span class="keywordflow">for</span> (EdgeVector::const_iterator j = i + 1; j != <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.end(); j++) {
<a name="l00418"></a>00418             <span class="keywordtype">bool</span> isOpposite = <span class="keyword">false</span>;
<a name="l00419"></a>00419             <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#a08b9d7171d43008a27c5443a5275966a">getOppositeIncoming</a>(*j) == *i &amp;&amp; <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.size() &gt; 2) {
<a name="l00420"></a>00420                 isOpposite = <span class="keyword">true</span>;
<a name="l00421"></a>00421             }
<a name="l00422"></a>00422 
<a name="l00423"></a>00423             <span class="comment">// This usage of defaults is not very well, still we do not have any</span>
<a name="l00424"></a>00424             <span class="comment">//  methods for the conversion of foreign, sometimes not supplied</span>
<a name="l00425"></a>00425             <span class="comment">//  road types into an own format</span>
<a name="l00426"></a>00426             <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#ab28dfb39f850f0859f8e28940b7ff60b" title="Numbers representing special SUMO-XML-attribute values for representing node- (junction-)...">SumoXMLNodeType</a> tmptype = type;
<a name="l00427"></a>00427             <span class="keywordflow">if</span> (!isOpposite) {
<a name="l00428"></a>00428                 tmptype = tc.<a class="code" href="../../db/d57/class_n_b_type_cont.html#aba041c46b59e5f0d18f961edd02f299b" title="Returns the type of the junction between two edges of the given types.">getJunctionType</a>((*i)-&gt;getSpeed(), (*j)-&gt;getSpeed());
<a name="l00429"></a>00429                 <span class="keywordflow">if</span> (tmptype &lt; type &amp;&amp; tmptype != <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#ab28dfb39f850f0859f8e28940b7ff60ba83f3842f496fa9a36448211498a4f4f4">NODETYPE_UNKNOWN</a> &amp;&amp; tmptype != <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#ab28dfb39f850f0859f8e28940b7ff60ba1bbeaa02fa0063bb67f1dcdafba01a83">NODETYPE_NOJUNCTION</a>) {
<a name="l00430"></a>00430                     type = tmptype;
<a name="l00431"></a>00431                 }
<a name="l00432"></a>00432             }
<a name="l00433"></a>00433         }
<a name="l00434"></a>00434     }
<a name="l00435"></a>00435     <a class="code" href="../../d3/dd1/class_n_b_node.html#a4547c21e970c3ca1cdf98d20c347ffdc" title="The type of the junction.">myType</a> = type;
<a name="l00436"></a>00436 }
<a name="l00437"></a>00437 
<a name="l00438"></a>00438 
<a name="l00439"></a>00439 <span class="keywordtype">bool</span>
<a name="l00440"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#ad7e5a6a250bc116265c8c2898a83c247">00440</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#ad7e5a6a250bc116265c8c2898a83c247">NBNode::isSimpleContinuation</a>()<span class="keyword"> const </span>{
<a name="l00441"></a>00441     <span class="comment">// one in, one out-&gt;continuation</span>
<a name="l00442"></a>00442     <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.size() == 1 &amp;&amp; <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.size() == 1) {
<a name="l00443"></a>00443         <span class="comment">// both must have the same number of lanes</span>
<a name="l00444"></a>00444         <span class="keywordflow">return</span> (*(<a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.begin()))-&gt;getNumLanes() == (*(<a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.begin()))-&gt;getNumLanes();
<a name="l00445"></a>00445     }
<a name="l00446"></a>00446     <span class="comment">// two in and two out and both in reverse direction</span>
<a name="l00447"></a>00447     <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.size() == 2 &amp;&amp; <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.size() == 2) {
<a name="l00448"></a>00448         <span class="keywordflow">for</span> (EdgeVector::const_iterator i = <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.begin(); i != <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.end(); i++) {
<a name="l00449"></a>00449             <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* in = *i;
<a name="l00450"></a>00450             EdgeVector::const_iterator opposite = find_if(<a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.begin(), <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.end(), <a class="code" href="../../d0/d53/class_n_b_cont_helper_1_1opposite__finder.html">NBContHelper::opposite_finder</a>(in, <span class="keyword">this</span>));
<a name="l00451"></a>00451             <span class="comment">// must have an opposite edge</span>
<a name="l00452"></a>00452             <span class="keywordflow">if</span> (opposite == <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.end()) {
<a name="l00453"></a>00453                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00454"></a>00454             }
<a name="l00455"></a>00455             <span class="comment">// both must have the same number of lanes</span>
<a name="l00456"></a>00456             <a class="code" href="../../df/d78/class_n_b_cont_helper.html#a27ff78c70d9a3f11b7dafd6f2bab51ee">NBContHelper::nextCW</a>(<a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>, opposite);
<a name="l00457"></a>00457             <span class="keywordflow">if</span> (in-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#aa6ed274bbffc247a43e91a8ec4b150a1" title="Returns the number of lanes.">getNumLanes</a>() != (*opposite)-&gt;getNumLanes()) {
<a name="l00458"></a>00458                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00459"></a>00459             }
<a name="l00460"></a>00460         }
<a name="l00461"></a>00461         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00462"></a>00462     }
<a name="l00463"></a>00463     <span class="comment">// nope</span>
<a name="l00464"></a>00464     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00465"></a>00465 }
<a name="l00466"></a>00466 
<a name="l00467"></a>00467 
<a name="l00468"></a>00468 <span class="keywordtype">bool</span>
<a name="l00469"></a><a class="code" href="../../d4/d41/_n_b_node_8cpp.html#a73a4b09a551e543d0c0cccd6e86da558">00469</a> <a class="code" href="../../d4/d41/_n_b_node_8cpp.html#a73a4b09a551e543d0c0cccd6e86da558">samePriority</a>(<a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* e1, <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* e2) {
<a name="l00470"></a>00470     <span class="keywordflow">if</span> (e1 == e2) {
<a name="l00471"></a>00471         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00472"></a>00472     }
<a name="l00473"></a>00473     <span class="keywordflow">if</span> (e1-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#ae3863d2a0e00bb37e381700a40729a07" title="Returns the priority of the edge.">getPriority</a>() != e2-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#ae3863d2a0e00bb37e381700a40729a07" title="Returns the priority of the edge.">getPriority</a>()) {
<a name="l00474"></a>00474         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00475"></a>00475     }
<a name="l00476"></a>00476     <span class="keywordflow">if</span> ((<span class="keywordtype">int</span>) e1-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#a6fa897ead9e371c1e431b8076550e74a" title="Returns the speed allowed on this edge.">getSpeed</a>() != (int) e2-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#a6fa897ead9e371c1e431b8076550e74a" title="Returns the speed allowed on this edge.">getSpeed</a>()) {
<a name="l00477"></a>00477         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00478"></a>00478     }
<a name="l00479"></a>00479     <span class="keywordflow">return</span> (<span class="keywordtype">int</span>) e1-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#aa6ed274bbffc247a43e91a8ec4b150a1" title="Returns the number of lanes.">getNumLanes</a>() == (int) e2-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#aa6ed274bbffc247a43e91a8ec4b150a1" title="Returns the number of lanes.">getNumLanes</a>();
<a name="l00480"></a>00480 }
<a name="l00481"></a>00481 
<a name="l00482"></a>00482 
<a name="l00483"></a>00483 <span class="keywordtype">void</span>
<a name="l00484"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#ac93daf7fc4c95c43036d2c80192e7d48">00484</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#ac93daf7fc4c95c43036d2c80192e7d48" title="sets the priorites in case of a priority junction">NBNode::setPriorityJunctionPriorities</a>() {
<a name="l00485"></a>00485     <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.size() == 0 || <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.size() == 0) {
<a name="l00486"></a>00486         <span class="keywordflow">return</span>;
<a name="l00487"></a>00487     }
<a name="l00488"></a>00488     <a class="code" href="../../db/dde/_n_b_cont_8h.html#a7bbd80497f8b27f18697210825ec974a">EdgeVector</a> incoming = <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>;
<a name="l00489"></a>00489     <a class="code" href="../../db/dde/_n_b_cont_8h.html#a7bbd80497f8b27f18697210825ec974a">EdgeVector</a> outgoing = <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>;
<a name="l00490"></a>00490     <span class="comment">// what we do want to have is to extract the pair of roads that are</span>
<a name="l00491"></a>00491     <span class="comment">//  the major roads for this junction</span>
<a name="l00492"></a>00492     <span class="comment">// let&#39;s get the list of incoming edges with the highest priority</span>
<a name="l00493"></a>00493     std::sort(incoming.begin(), incoming.end(), <a class="code" href="../../d5/d05/class_n_b_cont_helper_1_1edge__by__priority__sorter.html">NBContHelper::edge_by_priority_sorter</a>());
<a name="l00494"></a>00494     <a class="code" href="../../db/dde/_n_b_cont_8h.html#a7bbd80497f8b27f18697210825ec974a">EdgeVector</a> bestIncoming;
<a name="l00495"></a>00495     <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* best = incoming[0];
<a name="l00496"></a>00496     <span class="keywordflow">while</span> (incoming.size() &gt; 0 &amp;&amp; <a class="code" href="../../d4/d41/_n_b_node_8cpp.html#a73a4b09a551e543d0c0cccd6e86da558">samePriority</a>(best, incoming[0])) {
<a name="l00497"></a>00497         bestIncoming.push_back(*incoming.begin());
<a name="l00498"></a>00498         incoming.erase(incoming.begin());
<a name="l00499"></a>00499     }
<a name="l00500"></a>00500     <span class="comment">// now, let&#39;s get the list of best outgoing</span>
<a name="l00501"></a>00501     assert(outgoing.size() != 0);
<a name="l00502"></a>00502     sort(outgoing.begin(), outgoing.end(), <a class="code" href="../../d5/d05/class_n_b_cont_helper_1_1edge__by__priority__sorter.html">NBContHelper::edge_by_priority_sorter</a>());
<a name="l00503"></a>00503     <a class="code" href="../../db/dde/_n_b_cont_8h.html#a7bbd80497f8b27f18697210825ec974a">EdgeVector</a> bestOutgoing;
<a name="l00504"></a>00504     best = outgoing[0];
<a name="l00505"></a>00505     <span class="keywordflow">while</span> (outgoing.size() &gt; 0 &amp;&amp; <a class="code" href="../../d4/d41/_n_b_node_8cpp.html#a73a4b09a551e543d0c0cccd6e86da558">samePriority</a>(best, outgoing[0])) { <span class="comment">//-&gt;getPriority()==best-&gt;getPriority()) {</span>
<a name="l00506"></a>00506         bestOutgoing.push_back(*outgoing.begin());
<a name="l00507"></a>00507         outgoing.erase(outgoing.begin());
<a name="l00508"></a>00508     }
<a name="l00509"></a>00509     <span class="comment">// now, let&#39;s compute for each of the best incoming edges</span>
<a name="l00510"></a>00510     <span class="comment">//  the incoming which is most opposite</span>
<a name="l00511"></a>00511     <span class="comment">//  the outgoing which is most opposite</span>
<a name="l00512"></a>00512     EdgeVector::iterator i;
<a name="l00513"></a>00513     std::map&lt;NBEdge*, NBEdge*&gt; counterIncomingEdges;
<a name="l00514"></a>00514     std::map&lt;NBEdge*, NBEdge*&gt; counterOutgoingEdges;
<a name="l00515"></a>00515     incoming = <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>;
<a name="l00516"></a>00516     outgoing = <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>;
<a name="l00517"></a>00517     <span class="keywordflow">for</span> (i = bestIncoming.begin(); i != bestIncoming.end(); ++i) {
<a name="l00518"></a>00518         std::sort(incoming.begin(), incoming.end(), <a class="code" href="../../d8/d3c/class_n_b_cont_helper_1_1edge__opposite__direction__sorter.html" title="Class to sort edges by their angle in relation to the given edge.">NBContHelper::edge_opposite_direction_sorter</a>(*i, <span class="keyword">this</span>));
<a name="l00519"></a>00519         counterIncomingEdges[*i] = *incoming.begin();
<a name="l00520"></a>00520         std::sort(outgoing.begin(), outgoing.end(), <a class="code" href="../../d8/d3c/class_n_b_cont_helper_1_1edge__opposite__direction__sorter.html" title="Class to sort edges by their angle in relation to the given edge.">NBContHelper::edge_opposite_direction_sorter</a>(*i, <span class="keyword">this</span>));
<a name="l00521"></a>00521         counterOutgoingEdges[*i] = *outgoing.begin();
<a name="l00522"></a>00522     }
<a name="l00523"></a>00523     <span class="comment">// ok, let&#39;s try</span>
<a name="l00524"></a>00524     <span class="comment">// 1) there is one best incoming road</span>
<a name="l00525"></a>00525     <span class="keywordflow">if</span> (bestIncoming.size() == 1) {
<a name="l00526"></a>00526         <span class="comment">// let&#39;s mark this road as the best</span>
<a name="l00527"></a>00527         <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* best1 = <a class="code" href="../../d3/dd1/class_n_b_node.html#afcddc1eb2984920d3aa9739a2b1dbc4c">extractAndMarkFirst</a>(bestIncoming);
<a name="l00528"></a>00528         <span class="keywordflow">if</span> (bestOutgoing.size() != 0) {
<a name="l00529"></a>00529             <span class="comment">// mark the best outgoing as the continuation</span>
<a name="l00530"></a>00530             sort(bestOutgoing.begin(), bestOutgoing.end(), <a class="code" href="../../d1/d58/class_n_b_cont_helper_1_1edge__similar__direction__sorter.html">NBContHelper::edge_similar_direction_sorter</a>(best1));
<a name="l00531"></a>00531             <a class="code" href="../../d3/dd1/class_n_b_node.html#afcddc1eb2984920d3aa9739a2b1dbc4c">extractAndMarkFirst</a>(bestOutgoing);
<a name="l00532"></a>00532         }
<a name="l00533"></a>00533         <span class="keywordflow">return</span>;
<a name="l00534"></a>00534     }
<a name="l00535"></a>00535     <span class="comment">// 2b) there are more than one best incoming roads</span>
<a name="l00536"></a>00536     <span class="comment">//      and the same number of best outgoing roads</span>
<a name="l00537"></a>00537 
<a name="l00538"></a>00538     <span class="comment">// ok, what we want to do in this case is to determine which incoming</span>
<a name="l00539"></a>00539     <span class="comment">//  has the best continuation...</span>
<a name="l00540"></a>00540     <span class="comment">// This means, when several incoming roads have the same priority,</span>
<a name="l00541"></a>00541     <span class="comment">//  we want a (any) straight connection to be more priorised than a turning</span>
<a name="l00542"></a>00542     <a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a> bestAngle = 0;
<a name="l00543"></a>00543     <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* bestFirst = 0;
<a name="l00544"></a>00544     <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* bestSecond = 0;
<a name="l00545"></a>00545     <span class="keywordtype">bool</span> hadBest = <span class="keyword">false</span>;
<a name="l00546"></a>00546     <span class="keywordflow">for</span> (i = bestIncoming.begin(); i != bestIncoming.end(); ++i) {
<a name="l00547"></a>00547         EdgeVector::iterator j;
<a name="l00548"></a>00548         <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* t1 = *i;
<a name="l00549"></a>00549         <a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a> angle1 = t1-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#a35a4bbaea9501ed0a2cd38a7f97b7086" title="Returns the angle of the edge.">getAngle</a>() + 180;
<a name="l00550"></a>00550         <span class="keywordflow">if</span> (angle1 &gt;= 360) {
<a name="l00551"></a>00551             angle1 -= 360;
<a name="l00552"></a>00552         }
<a name="l00553"></a>00553         <span class="keywordflow">for</span> (j = i + 1; j != bestIncoming.end(); ++j) {
<a name="l00554"></a>00554             <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* t2 = *j;
<a name="l00555"></a>00555             <a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a> angle2 = t2-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#a35a4bbaea9501ed0a2cd38a7f97b7086" title="Returns the angle of the edge.">getAngle</a>() + 180;
<a name="l00556"></a>00556             <span class="keywordflow">if</span> (angle2 &gt;= 360) {
<a name="l00557"></a>00557                 angle2 -= 360;
<a name="l00558"></a>00558             }
<a name="l00559"></a>00559             <a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a> angle = <a class="code" href="../../d3/de6/class_geom_helper.html#aa0f30814c9a5db52db90eccad5947043" title="Returns the minimum distance (clockwise/counter-clockwise) between both angles.">GeomHelper::getMinAngleDiff</a>(angle1, angle2);
<a name="l00560"></a>00560             <span class="keywordflow">if</span> (!hadBest || angle &gt; bestAngle) {
<a name="l00561"></a>00561                 bestAngle = angle;
<a name="l00562"></a>00562                 bestFirst = *i;
<a name="l00563"></a>00563                 bestSecond = *j;
<a name="l00564"></a>00564                 hadBest = <span class="keyword">true</span>;
<a name="l00565"></a>00565             }
<a name="l00566"></a>00566         }
<a name="l00567"></a>00567     }
<a name="l00568"></a>00568     bestFirst-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#af962ccc981e0b8b5e4f3487f62f5c6b7" title="Sets the junction priority of the edge.">setJunctionPriority</a>(<span class="keyword">this</span>, 1);
<a name="l00569"></a>00569     sort(bestOutgoing.begin(), bestOutgoing.end(), <a class="code" href="../../d1/d58/class_n_b_cont_helper_1_1edge__similar__direction__sorter.html">NBContHelper::edge_similar_direction_sorter</a>(bestFirst));
<a name="l00570"></a>00570     <span class="keywordflow">if</span> (bestOutgoing.size() != 0) {
<a name="l00571"></a>00571         <a class="code" href="../../d3/dd1/class_n_b_node.html#afcddc1eb2984920d3aa9739a2b1dbc4c">extractAndMarkFirst</a>(bestOutgoing);
<a name="l00572"></a>00572     }
<a name="l00573"></a>00573     bestSecond-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#af962ccc981e0b8b5e4f3487f62f5c6b7" title="Sets the junction priority of the edge.">setJunctionPriority</a>(<span class="keyword">this</span>, 1);
<a name="l00574"></a>00574     sort(bestOutgoing.begin(), bestOutgoing.end(), <a class="code" href="../../d1/d58/class_n_b_cont_helper_1_1edge__similar__direction__sorter.html">NBContHelper::edge_similar_direction_sorter</a>(bestSecond));
<a name="l00575"></a>00575     <span class="keywordflow">if</span> (bestOutgoing.size() != 0) {
<a name="l00576"></a>00576         <a class="code" href="../../d3/dd1/class_n_b_node.html#afcddc1eb2984920d3aa9739a2b1dbc4c">extractAndMarkFirst</a>(bestOutgoing);
<a name="l00577"></a>00577     }
<a name="l00578"></a>00578 }
<a name="l00579"></a>00579 
<a name="l00580"></a>00580 
<a name="l00581"></a>00581 <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>*
<a name="l00582"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#afcddc1eb2984920d3aa9739a2b1dbc4c">00582</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#afcddc1eb2984920d3aa9739a2b1dbc4c">NBNode::extractAndMarkFirst</a>(<a class="code" href="../../db/dde/_n_b_cont_8h.html#a7bbd80497f8b27f18697210825ec974a">EdgeVector</a>&amp; s) {
<a name="l00583"></a>00583     <span class="keywordflow">if</span> (s.size() == 0) {
<a name="l00584"></a>00584         <span class="keywordflow">return</span> 0;
<a name="l00585"></a>00585     }
<a name="l00586"></a>00586     <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* ret = s.front();
<a name="l00587"></a>00587     s.erase(s.begin());
<a name="l00588"></a>00588     ret-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#af962ccc981e0b8b5e4f3487f62f5c6b7" title="Sets the junction priority of the edge.">setJunctionPriority</a>(<span class="keyword">this</span>, 1);
<a name="l00589"></a>00589     <span class="keywordflow">return</span> ret;
<a name="l00590"></a>00590 }
<a name="l00591"></a>00591 
<a name="l00592"></a>00592 
<a name="l00593"></a>00593 <a class="code" href="../../da/d56/class_position_vector.html" title="A list of 2D-positions.">PositionVector</a>
<a name="l00594"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#af839fe682ffdc4ddf5b1c02dff9ddbc8">00594</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#af839fe682ffdc4ddf5b1c02dff9ddbc8" title="Compute the shape for an internal lane.">NBNode::computeInternalLaneShape</a>(<a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* fromE, <span class="keywordtype">int</span> fromL,
<a name="l00595"></a>00595                                  <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* toE, <span class="keywordtype">int</span> toL, <span class="keywordtype">int</span> numPoints)<span class="keyword"> const </span>{
<a name="l00596"></a>00596     <span class="keywordflow">if</span> (fromL &gt;= (<span class="keywordtype">int</span>) fromE-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#aa6ed274bbffc247a43e91a8ec4b150a1" title="Returns the number of lanes.">getNumLanes</a>()) {
<a name="l00597"></a>00597         <span class="keywordflow">throw</span> <a class="code" href="../../da/d18/class_process_error.html">ProcessError</a>(<span class="stringliteral">&quot;Connection &#39;&quot;</span> + fromE-&gt;<a class="code" href="../../d5/dbf/class_named.html#a20fd12b55c213fd79eae9fdd47b14eb1" title="Returns the id.">getID</a>() + <span class="stringliteral">&quot;_&quot;</span> + <a class="code" href="../../d8/d08/_to_string_8h.html#a18065e342d6bcbee25664108f38176f9">toString</a>(fromL) + <span class="stringliteral">&quot;-&gt;&quot;</span> + toE-&gt;<a class="code" href="../../d5/dbf/class_named.html#a20fd12b55c213fd79eae9fdd47b14eb1" title="Returns the id.">getID</a>() + <span class="stringliteral">&quot;_&quot;</span> + <a class="code" href="../../d8/d08/_to_string_8h.html#a18065e342d6bcbee25664108f38176f9">toString</a>(toL) + <span class="stringliteral">&quot;&#39; starts at a not existing lane.&quot;</span>);
<a name="l00598"></a>00598     }
<a name="l00599"></a>00599     <span class="keywordflow">if</span> (toL &gt;= (<span class="keywordtype">int</span>) toE-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#aa6ed274bbffc247a43e91a8ec4b150a1" title="Returns the number of lanes.">getNumLanes</a>()) {
<a name="l00600"></a>00600         <span class="keywordflow">throw</span> <a class="code" href="../../da/d18/class_process_error.html">ProcessError</a>(<span class="stringliteral">&quot;Connection &#39;&quot;</span> + fromE-&gt;<a class="code" href="../../d5/dbf/class_named.html#a20fd12b55c213fd79eae9fdd47b14eb1" title="Returns the id.">getID</a>() + <span class="stringliteral">&quot;_&quot;</span> + <a class="code" href="../../d8/d08/_to_string_8h.html#a18065e342d6bcbee25664108f38176f9">toString</a>(fromL) + <span class="stringliteral">&quot;-&gt;&quot;</span> + toE-&gt;<a class="code" href="../../d5/dbf/class_named.html#a20fd12b55c213fd79eae9fdd47b14eb1" title="Returns the id.">getID</a>() + <span class="stringliteral">&quot;_&quot;</span> + <a class="code" href="../../d8/d08/_to_string_8h.html#a18065e342d6bcbee25664108f38176f9">toString</a>(toL) + <span class="stringliteral">&quot;&#39; yields in a not existing lane.&quot;</span>);
<a name="l00601"></a>00601     }
<a name="l00602"></a>00602     <span class="keywordtype">bool</span> noSpline = <span class="keyword">false</span>;
<a name="l00603"></a>00603     <a class="code" href="../../da/d56/class_position_vector.html" title="A list of 2D-positions.">PositionVector</a> ret;
<a name="l00604"></a>00604     <a class="code" href="../../da/d56/class_position_vector.html" title="A list of 2D-positions.">PositionVector</a> init;
<a name="l00605"></a>00605     <a class="code" href="../../d7/d3b/class_position.html" title="A point in 2D or 3D with translation and scaling methods.">Position</a> beg = fromE-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#aff02ac4df26f811170dfe3c32c6fd4a8" title="Returns the shape of the nth lane.">getLaneShape</a>(fromL).<a class="code" href="../../da/d56/class_position_vector.html#ab1ff1594b2b0650bfbe8eba494b2b8df" title="Returns the last position.">getEnd</a>();
<a name="l00606"></a>00606     <a class="code" href="../../d7/d3b/class_position.html" title="A point in 2D or 3D with translation and scaling methods.">Position</a> end = toE-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#aff02ac4df26f811170dfe3c32c6fd4a8" title="Returns the shape of the nth lane.">getLaneShape</a>(toL).<a class="code" href="../../da/d56/class_position_vector.html#ac0945c0900de7db3d965e4f5742f1609" title="Returns the first position.">getBegin</a>();
<a name="l00607"></a>00607     <a class="code" href="../../d7/d3b/class_position.html" title="A point in 2D or 3D with translation and scaling methods.">Position</a> intersection;
<a name="l00608"></a>00608     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> noInitialPoints = 0;
<a name="l00609"></a>00609     <span class="keywordflow">if</span> (beg.<a class="code" href="../../d7/d3b/class_position.html#aaa1d5d9e58bc203fceee0002563c3bc2" title="returns the euclidean distance in 3 dimension">distanceTo</a>(end) &lt;= <a class="code" href="../../db/d16/config_8h.html#af94afeb21356793ecd34d4b7bef68d50">POSITION_EPS</a>) {
<a name="l00610"></a>00610         noSpline = <span class="keyword">true</span>;
<a name="l00611"></a>00611     } <span class="keywordflow">else</span> {
<a name="l00612"></a>00612         <span class="keywordflow">if</span> (fromE-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#a4acf76dc68775ec29767a43e95c907aa">getTurnDestination</a>() == toE) {
<a name="l00613"></a>00613             <span class="comment">// turnarounds:</span>
<a name="l00614"></a>00614             <span class="comment">//  - end of incoming lane</span>
<a name="l00615"></a>00615             <span class="comment">//  - position between incoming/outgoing end/begin shifted by the distace orthogonally</span>
<a name="l00616"></a>00616             <span class="comment">//  - begin of outgoing lane</span>
<a name="l00617"></a>00617             noInitialPoints = 3;
<a name="l00618"></a>00618             init.<a class="code" href="../../da/d56/class_position_vector.html#a99a6f657973c8a916ffa8ebca2b33d80" title="Appends the given position to the list.">push_back</a>(beg);
<a name="l00619"></a>00619             <a class="code" href="../../dd/db4/class_line.html">Line</a> straightConn(fromE-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#aff02ac4df26f811170dfe3c32c6fd4a8" title="Returns the shape of the nth lane.">getLaneShape</a>(fromL)[-1], toE-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#aff02ac4df26f811170dfe3c32c6fd4a8" title="Returns the shape of the nth lane.">getLaneShape</a>(toL)[0]);
<a name="l00620"></a>00620             <a class="code" href="../../d7/d3b/class_position.html" title="A point in 2D or 3D with translation and scaling methods.">Position</a> straightCenter = straightConn.getPositionAtDistance((<a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a>) straightConn.length() / (<a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a>) 2.);
<a name="l00621"></a>00621             <a class="code" href="../../d7/d3b/class_position.html" title="A point in 2D or 3D with translation and scaling methods.">Position</a> center = straightCenter;<span class="comment">//.add(straightCenter);</span>
<a name="l00622"></a>00622             <a class="code" href="../../dd/db4/class_line.html">Line</a> cross(straightConn);
<a name="l00623"></a>00623             cross.<a class="code" href="../../dd/db4/class_line.html#a4f90254f209bb8f80f326c11e16372d3">sub</a>(cross.<a class="code" href="../../dd/db4/class_line.html#ac540233226a863d9a3ca2b7e147a2e8d">p1</a>().<a class="code" href="../../d7/d3b/class_position.html#a51c33a67d08730631a34482850b2203b" title="Returns the x-position.">x</a>(), cross.<a class="code" href="../../dd/db4/class_line.html#ac540233226a863d9a3ca2b7e147a2e8d">p1</a>().<a class="code" href="../../d7/d3b/class_position.html#a4a65556f1de2548b23ce662f81c7ab1a" title="Returns the y-position.">y</a>());
<a name="l00624"></a>00624             cross.<a class="code" href="../../dd/db4/class_line.html#aa128130be7e629536850e48f68234784">rotateAtP1</a>(<a class="code" href="../../d1/dc9/polyfonts_8c.html#a598a3330b3c21701223ee0ca14316eca">PI</a> / 2);
<a name="l00625"></a>00625             center.<a class="code" href="../../d7/d3b/class_position.html#a29103befbc903bc4d16ba9899cb49fbe" title="Substracts the given position from this one.">sub</a>(cross.<a class="code" href="../../dd/db4/class_line.html#ab2133d17752fc559efc811aa41910126">p2</a>());
<a name="l00626"></a>00626             init.<a class="code" href="../../da/d56/class_position_vector.html#a99a6f657973c8a916ffa8ebca2b33d80" title="Appends the given position to the list.">push_back</a>(center);
<a name="l00627"></a>00627             init.<a class="code" href="../../da/d56/class_position_vector.html#a99a6f657973c8a916ffa8ebca2b33d80" title="Appends the given position to the list.">push_back</a>(end);
<a name="l00628"></a>00628         } <span class="keywordflow">else</span> {
<a name="l00629"></a>00629             <span class="keyword">const</span> <a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a> angle = fabs(fromE-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#aff02ac4df26f811170dfe3c32c6fd4a8" title="Returns the shape of the nth lane.">getLaneShape</a>(fromL).<a class="code" href="../../da/d56/class_position_vector.html#a70b0ff575e778c922d01d83261c607a7">getEndLine</a>().<a class="code" href="../../dd/db4/class_line.html#a45b92601f3e9038616215ab84761a698">atan2Angle</a>() - toE-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#aff02ac4df26f811170dfe3c32c6fd4a8" title="Returns the shape of the nth lane.">getLaneShape</a>(toL).<a class="code" href="../../da/d56/class_position_vector.html#ab00c73cbda7d82f9b06908534c13ddba">getBegLine</a>().<a class="code" href="../../dd/db4/class_line.html#a45b92601f3e9038616215ab84761a698">atan2Angle</a>());
<a name="l00630"></a>00630             <span class="keywordflow">if</span> (angle &lt; PI / 4. || angle &gt; 7. / 4.*<a class="code" href="../../d1/dc9/polyfonts_8c.html#a598a3330b3c21701223ee0ca14316eca">PI</a>) {
<a name="l00631"></a>00631                 <span class="comment">// very low angle: almost straight</span>
<a name="l00632"></a>00632                 noInitialPoints = 4;
<a name="l00633"></a>00633                 init.<a class="code" href="../../da/d56/class_position_vector.html#a99a6f657973c8a916ffa8ebca2b33d80" title="Appends the given position to the list.">push_back</a>(beg);
<a name="l00634"></a>00634                 <a class="code" href="../../dd/db4/class_line.html">Line</a> begL = fromE-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#aff02ac4df26f811170dfe3c32c6fd4a8" title="Returns the shape of the nth lane.">getLaneShape</a>(fromL).<a class="code" href="../../da/d56/class_position_vector.html#a70b0ff575e778c922d01d83261c607a7">getEndLine</a>();
<a name="l00635"></a>00635                 begL.<a class="code" href="../../dd/db4/class_line.html#abd17e553e0d0023034b61554b1301eb6">extrapolateSecondBy</a>(100);
<a name="l00636"></a>00636                 <a class="code" href="../../dd/db4/class_line.html">Line</a> endL = toE-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#aff02ac4df26f811170dfe3c32c6fd4a8" title="Returns the shape of the nth lane.">getLaneShape</a>(toL).<a class="code" href="../../da/d56/class_position_vector.html#ab00c73cbda7d82f9b06908534c13ddba">getBegLine</a>();
<a name="l00637"></a>00637                 endL.<a class="code" href="../../dd/db4/class_line.html#a52450ad39f8bc65e091f0d9c64171c25">extrapolateFirstBy</a>(100);
<a name="l00638"></a>00638                 <a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a> distance = beg.<a class="code" href="../../d7/d3b/class_position.html#aaa1d5d9e58bc203fceee0002563c3bc2" title="returns the euclidean distance in 3 dimension">distanceTo</a>(end);
<a name="l00639"></a>00639                 <span class="keywordflow">if</span> (distance &gt; 10) {
<a name="l00640"></a>00640                     {
<a name="l00641"></a>00641                         <a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a> off1 = fromE-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#aff02ac4df26f811170dfe3c32c6fd4a8" title="Returns the shape of the nth lane.">getLaneShape</a>(fromL).<a class="code" href="../../da/d56/class_position_vector.html#a70b0ff575e778c922d01d83261c607a7">getEndLine</a>().<a class="code" href="../../dd/db4/class_line.html#af801560a8f5dca5c83b6054d3101a691">length</a>() + (<a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a>) 5. * (<a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a>) fromE-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#aa6ed274bbffc247a43e91a8ec4b150a1" title="Returns the number of lanes.">getNumLanes</a>();
<a name="l00642"></a>00642                         off1 = <a class="code" href="../../da/dbd/_std_defs_8h.html#addea5df1107152d65231122e3dfad6fb">MIN2</a>(off1, (<a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a>)(fromE-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#aff02ac4df26f811170dfe3c32c6fd4a8" title="Returns the shape of the nth lane.">getLaneShape</a>(fromL).<a class="code" href="../../da/d56/class_position_vector.html#a70b0ff575e778c922d01d83261c607a7">getEndLine</a>().<a class="code" href="../../dd/db4/class_line.html#af801560a8f5dca5c83b6054d3101a691">length</a>() + distance / 2.));
<a name="l00643"></a>00643                         <a class="code" href="../../d7/d3b/class_position.html" title="A point in 2D or 3D with translation and scaling methods.">Position</a> tmp = begL.<a class="code" href="../../dd/db4/class_line.html#a8f1866de2164bf74109d604e3487ec29">getPositionAtDistance</a>(off1);
<a name="l00644"></a>00644                         init.<a class="code" href="../../da/d56/class_position_vector.html#a99a6f657973c8a916ffa8ebca2b33d80" title="Appends the given position to the list.">push_back</a>(tmp);
<a name="l00645"></a>00645                     }
<a name="l00646"></a>00646                     {
<a name="l00647"></a>00647                         <a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a> off1 = (<a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a>) 100. - (<a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a>) 5. * (<a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a>) toE-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#aa6ed274bbffc247a43e91a8ec4b150a1" title="Returns the number of lanes.">getNumLanes</a>();
<a name="l00648"></a>00648                         off1 = <a class="code" href="../../da/dbd/_std_defs_8h.html#a3c4556662cf5cb93067cdc7365aecbcd">MAX2</a>(off1, (<a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a>)(100. - distance / 2.));
<a name="l00649"></a>00649                         <a class="code" href="../../d7/d3b/class_position.html" title="A point in 2D or 3D with translation and scaling methods.">Position</a> tmp = endL.<a class="code" href="../../dd/db4/class_line.html#a8f1866de2164bf74109d604e3487ec29">getPositionAtDistance</a>(off1);
<a name="l00650"></a>00650                         init.<a class="code" href="../../da/d56/class_position_vector.html#a99a6f657973c8a916ffa8ebca2b33d80" title="Appends the given position to the list.">push_back</a>(tmp);
<a name="l00651"></a>00651                     }
<a name="l00652"></a>00652                 } <span class="keywordflow">else</span> {
<a name="l00653"></a>00653                     noSpline = <span class="keyword">true</span>;
<a name="l00654"></a>00654                 }
<a name="l00655"></a>00655                 init.<a class="code" href="../../da/d56/class_position_vector.html#a99a6f657973c8a916ffa8ebca2b33d80" title="Appends the given position to the list.">push_back</a>(end);
<a name="l00656"></a>00656             } <span class="keywordflow">else</span> {
<a name="l00657"></a>00657                 <span class="comment">// turning</span>
<a name="l00658"></a>00658                 <span class="comment">//  - end of incoming lane</span>
<a name="l00659"></a>00659                 <span class="comment">//  - intersection of the extrapolated lanes</span>
<a name="l00660"></a>00660                 <span class="comment">//  - begin of outgoing lane</span>
<a name="l00661"></a>00661                 <span class="comment">// attention: if there is no intersection, use a straight line</span>
<a name="l00662"></a>00662                 noInitialPoints = 3;
<a name="l00663"></a>00663                 init.<a class="code" href="../../da/d56/class_position_vector.html#a99a6f657973c8a916ffa8ebca2b33d80" title="Appends the given position to the list.">push_back</a>(beg);
<a name="l00664"></a>00664                 <a class="code" href="../../dd/db4/class_line.html">Line</a> begL = fromE-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#aff02ac4df26f811170dfe3c32c6fd4a8" title="Returns the shape of the nth lane.">getLaneShape</a>(fromL).<a class="code" href="../../da/d56/class_position_vector.html#a70b0ff575e778c922d01d83261c607a7">getEndLine</a>();
<a name="l00665"></a>00665                 <a class="code" href="../../dd/db4/class_line.html">Line</a> endL = toE-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#aff02ac4df26f811170dfe3c32c6fd4a8" title="Returns the shape of the nth lane.">getLaneShape</a>(toL).<a class="code" href="../../da/d56/class_position_vector.html#ab00c73cbda7d82f9b06908534c13ddba">getBegLine</a>();
<a name="l00666"></a>00666                 <span class="keywordtype">bool</span> check = !begL.<a class="code" href="../../dd/db4/class_line.html#ac540233226a863d9a3ca2b7e147a2e8d">p1</a>().<a class="code" href="../../d7/d3b/class_position.html#a1a26bf7c83f82681d024de2e2c7b15f4">almostSame</a>(begL.<a class="code" href="../../dd/db4/class_line.html#ab2133d17752fc559efc811aa41910126">p2</a>()) &amp;&amp; !endL.<a class="code" href="../../dd/db4/class_line.html#ac540233226a863d9a3ca2b7e147a2e8d">p1</a>().<a class="code" href="../../d7/d3b/class_position.html#a1a26bf7c83f82681d024de2e2c7b15f4">almostSame</a>(endL.<a class="code" href="../../dd/db4/class_line.html#ab2133d17752fc559efc811aa41910126">p2</a>());
<a name="l00667"></a>00667                 <span class="keywordflow">if</span> (check) {
<a name="l00668"></a>00668                     begL.<a class="code" href="../../dd/db4/class_line.html#abd17e553e0d0023034b61554b1301eb6">extrapolateSecondBy</a>(100);
<a name="l00669"></a>00669                     endL.<a class="code" href="../../dd/db4/class_line.html#a52450ad39f8bc65e091f0d9c64171c25">extrapolateFirstBy</a>(100);
<a name="l00670"></a>00670                 } <span class="keywordflow">else</span> {
<a name="l00671"></a>00671                     <a class="code" href="../../d4/df7/_msg_handler_8h.html#a6875e463bd2d24f027eba135e7a5fdfa">WRITE_WARNING</a>(<span class="stringliteral">&quot;Could not use edge geometry for internal lane, node &#39;&quot;</span> + <a class="code" href="../../d5/dbf/class_named.html#a20fd12b55c213fd79eae9fdd47b14eb1" title="Returns the id.">getID</a>() + <span class="stringliteral">&quot;&#39;.&quot;</span>);
<a name="l00672"></a>00672                 }
<a name="l00673"></a>00673                 <span class="keywordflow">if</span> (!check || !begL.<a class="code" href="../../dd/db4/class_line.html#a72b2536fcaf66eaeb8e1519088e9d410">intersects</a>(endL)) {
<a name="l00674"></a>00674                     noSpline = <span class="keyword">true</span>;
<a name="l00675"></a>00675                 } <span class="keywordflow">else</span> {
<a name="l00676"></a>00676                     init.<a class="code" href="../../da/d56/class_position_vector.html#a99a6f657973c8a916ffa8ebca2b33d80" title="Appends the given position to the list.">push_back</a>(begL.<a class="code" href="../../dd/db4/class_line.html#a72cb42ebca8b1fc643bb6a7e37a796d3">intersectsAt</a>(endL));
<a name="l00677"></a>00677                 }
<a name="l00678"></a>00678                 init.<a class="code" href="../../da/d56/class_position_vector.html#a99a6f657973c8a916ffa8ebca2b33d80" title="Appends the given position to the list.">push_back</a>(end);
<a name="l00679"></a>00679             }
<a name="l00680"></a>00680         }
<a name="l00681"></a>00681     }
<a name="l00682"></a>00682     <span class="comment">//</span>
<a name="l00683"></a>00683     <span class="keywordflow">if</span> (noSpline) {
<a name="l00684"></a>00684         ret.<a class="code" href="../../da/d56/class_position_vector.html#a99a6f657973c8a916ffa8ebca2b33d80" title="Appends the given position to the list.">push_back</a>(fromE-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#aff02ac4df26f811170dfe3c32c6fd4a8" title="Returns the shape of the nth lane.">getLaneShape</a>(fromL).<a class="code" href="../../da/d56/class_position_vector.html#ab1ff1594b2b0650bfbe8eba494b2b8df" title="Returns the last position.">getEnd</a>());
<a name="l00685"></a>00685         ret.<a class="code" href="../../da/d56/class_position_vector.html#a99a6f657973c8a916ffa8ebca2b33d80" title="Appends the given position to the list.">push_back</a>(toE-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#aff02ac4df26f811170dfe3c32c6fd4a8" title="Returns the shape of the nth lane.">getLaneShape</a>(toL).<a class="code" href="../../da/d56/class_position_vector.html#ac0945c0900de7db3d965e4f5742f1609" title="Returns the first position.">getBegin</a>());
<a name="l00686"></a>00686     } <span class="keywordflow">else</span> {
<a name="l00687"></a>00687         <a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a>* def = <span class="keyword">new</span> <a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a>[1 + noInitialPoints * 3];
<a name="l00688"></a>00688         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (int) init.<a class="code" href="../../da/d56/class_position_vector.html#a4f728d62950004e143aa921c5f64de2f" title="returns the number of points making up the line vector">size</a>(); ++i) {
<a name="l00689"></a>00689             <span class="comment">// starts at index 1</span>
<a name="l00690"></a>00690             def[i * 3 + 1] = init[i].x();
<a name="l00691"></a>00691             def[i * 3 + 2] = 0;
<a name="l00692"></a>00692             def[i * 3 + 3] = init[i].y();
<a name="l00693"></a>00693         }
<a name="l00694"></a>00694         <a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a>* ret_buf = <span class="keyword">new</span> <a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a>[numPoints * 3 + 1];
<a name="l00695"></a>00695         <a class="code" href="../../dc/d35/bezier_8cpp.html#a081b269ea5d9f381aa42eb0bd68a7312">bezier</a>(noInitialPoints, def, numPoints, ret_buf);
<a name="l00696"></a>00696         <span class="keyword">delete</span>[] def;
<a name="l00697"></a>00697         <a class="code" href="../../d7/d3b/class_position.html" title="A point in 2D or 3D with translation and scaling methods.">Position</a> prev;
<a name="l00698"></a>00698         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (int) numPoints; i++) {
<a name="l00699"></a>00699             <a class="code" href="../../d7/d3b/class_position.html" title="A point in 2D or 3D with translation and scaling methods.">Position</a> current(ret_buf[i * 3 + 1], ret_buf[i * 3 + 3]);
<a name="l00700"></a>00700             <span class="keywordflow">if</span> (prev != current) {
<a name="l00701"></a>00701                 ret.<a class="code" href="../../da/d56/class_position_vector.html#a99a6f657973c8a916ffa8ebca2b33d80" title="Appends the given position to the list.">push_back</a>(current);
<a name="l00702"></a>00702             }
<a name="l00703"></a>00703             prev = current;
<a name="l00704"></a>00704         }
<a name="l00705"></a>00705         <span class="keyword">delete</span>[] ret_buf;
<a name="l00706"></a>00706     }
<a name="l00707"></a>00707     <span class="keyword">const</span> <a class="code" href="../../dd/dbe/struct_n_b_edge_1_1_lane.html" title="An (internal) definition of a single lane of an edge.">NBEdge::Lane</a>&amp; lane = fromE-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#af0f7199354bbc635c61904e258a3ea17">getLaneStruct</a>(fromL);
<a name="l00708"></a>00708     <span class="keywordflow">if</span> (lane.<a class="code" href="../../dd/dbe/struct_n_b_edge_1_1_lane.html#a621e4c7323b689b0f4caa2555c495fef" title="This lane&amp;#39;s offset to the intersection begin.">offset</a> &gt; 0) {
<a name="l00709"></a>00709         <a class="code" href="../../da/d56/class_position_vector.html" title="A list of 2D-positions.">PositionVector</a> beg = lane.<a class="code" href="../../dd/dbe/struct_n_b_edge_1_1_lane.html#aed0084624ba1bb6fa499decaad0b38a2" title="The lane&amp;#39;s shape.">shape</a>.<a class="code" href="../../da/d56/class_position_vector.html#a24a8dee24c4996d7349d9998ee385d27">getSubpart</a>(lane.<a class="code" href="../../dd/dbe/struct_n_b_edge_1_1_lane.html#aed0084624ba1bb6fa499decaad0b38a2" title="The lane&amp;#39;s shape.">shape</a>.<a class="code" href="../../da/d56/class_position_vector.html#a83cd8142323cc67c4374fdc5c6244b8b" title="Returns the length.">length</a>() - lane.<a class="code" href="../../dd/dbe/struct_n_b_edge_1_1_lane.html#a621e4c7323b689b0f4caa2555c495fef" title="This lane&amp;#39;s offset to the intersection begin.">offset</a>, lane.<a class="code" href="../../dd/dbe/struct_n_b_edge_1_1_lane.html#aed0084624ba1bb6fa499decaad0b38a2" title="The lane&amp;#39;s shape.">shape</a>.<a class="code" href="../../da/d56/class_position_vector.html#a83cd8142323cc67c4374fdc5c6244b8b" title="Returns the length.">length</a>());;
<a name="l00710"></a>00710         beg.<a class="code" href="../../da/d56/class_position_vector.html#afaee168da63a916dafb3ffc62a8538cb">appendWithCrossingPoint</a>(ret);
<a name="l00711"></a>00711         ret = beg;
<a name="l00712"></a>00712     }
<a name="l00713"></a>00713     <span class="keywordflow">return</span> ret;
<a name="l00714"></a>00714 }
<a name="l00715"></a>00715 
<a name="l00716"></a>00716 
<a name="l00717"></a>00717 <span class="keywordtype">bool</span>
<a name="l00718"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#ac3e495e7e08634bbfaffd003e7952785">00718</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#ac3e495e7e08634bbfaffd003e7952785">NBNode::needsCont</a>(<a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* fromE, <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* toE, <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* otherFromE, <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* otherToE, <span class="keyword">const</span> <a class="code" href="../../d5/de2/struct_n_b_edge_1_1_connection.html" title="A structure which describes a connection between edges or lanes.">NBEdge::Connection</a>&amp; c)<span class="keyword"> const </span>{
<a name="l00719"></a>00719     <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#a4547c21e970c3ca1cdf98d20c347ffdc" title="The type of the junction.">myType</a> == <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#ab28dfb39f850f0859f8e28940b7ff60ba3ab04e8411b56a12f844bd542e004e73">NODETYPE_RIGHT_BEFORE_LEFT</a>) {
<a name="l00720"></a>00720         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00721"></a>00721     }
<a name="l00722"></a>00722     <span class="keywordflow">if</span> (fromE == otherFromE) {
<a name="l00723"></a>00723         <span class="comment">// ignore same edge links</span>
<a name="l00724"></a>00724         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00725"></a>00725     }
<a name="l00726"></a>00726     <span class="keywordflow">if</span> (!<a class="code" href="../../d3/dd1/class_n_b_node.html#a57da2da13804af5d849f61be6ee479cf" title="Returns the information whether the given flows cross.">foes</a>(otherFromE, otherToE, fromE, toE)) {
<a name="l00727"></a>00727         <span class="comment">// if they do not cross, no waiting place is needed</span>
<a name="l00728"></a>00728         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00729"></a>00729     }
<a name="l00730"></a>00730     <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#aa0b67dafb51a20429fabfa8d7a07d57e" title="The different directions a link between two lanes may take (or a stream between two...">LinkDirection</a> d1 = <a class="code" href="../../d3/dd1/class_n_b_node.html#a01b253c12dd598c6f9a7dbae85c3bab9" title="Returns the representation of the described stream&amp;#39;s direction.">getDirection</a>(fromE, toE);
<a name="l00731"></a>00731     <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#aa0b67dafb51a20429fabfa8d7a07d57e" title="The different directions a link between two lanes may take (or a stream between two...">LinkDirection</a> d2 = <a class="code" href="../../d3/dd1/class_n_b_node.html#a01b253c12dd598c6f9a7dbae85c3bab9" title="Returns the representation of the described stream&amp;#39;s direction.">getDirection</a>(otherFromE, otherToE);
<a name="l00732"></a>00732     <span class="keywordtype">bool</span> thisLeft = (d1 == <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#aa0b67dafb51a20429fabfa8d7a07d57eaad7740c4bcacf58c61c9b78b459a9b58" title="The link is a (hard) left direction.">LINKDIR_LEFT</a> || d1 == <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#aa0b67dafb51a20429fabfa8d7a07d57ea3a971c67f9867b2541430659aa19d9f9" title="The link is a 180 degree turn.">LINKDIR_TURN</a>);
<a name="l00733"></a>00733     <span class="keywordtype">bool</span> otherLeft = (d2 == <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#aa0b67dafb51a20429fabfa8d7a07d57eaad7740c4bcacf58c61c9b78b459a9b58" title="The link is a (hard) left direction.">LINKDIR_LEFT</a> || d2 == <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#aa0b67dafb51a20429fabfa8d7a07d57ea3a971c67f9867b2541430659aa19d9f9" title="The link is a 180 degree turn.">LINKDIR_TURN</a>);
<a name="l00734"></a>00734     <span class="keywordtype">bool</span> bothLeft = thisLeft &amp;&amp; otherLeft;
<a name="l00735"></a>00735     <span class="keywordflow">if</span> (c.<a class="code" href="../../d5/de2/struct_n_b_edge_1_1_connection.html#abd5ecf1076a6165e49955642a0bb9bf6" title="The id of the traffic light that controls this connection.">tlID</a> != <span class="stringliteral">&quot;&quot;</span> &amp;&amp; !bothLeft) {
<a name="l00736"></a>00736         <span class="comment">// tls-controlled links will have space</span>
<a name="l00737"></a>00737         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00738"></a>00738     }
<a name="l00739"></a>00739     <span class="keywordflow">if</span> (fromE-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#afe308c66528c9767f31384b2ffae5b30" title="Returns the junction priority (normalised for the node currently build).">getJunctionPriority</a>(<span class="keyword">this</span>) &gt; 0 &amp;&amp; otherFromE-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#afe308c66528c9767f31384b2ffae5b30" title="Returns the junction priority (normalised for the node currently build).">getJunctionPriority</a>(<span class="keyword">this</span>) &gt; 0) {
<a name="l00740"></a>00740         <span class="keywordflow">return</span> <a class="code" href="../../d3/dd1/class_n_b_node.html#a7c615b8ed5ba49be632dc68e825cca33" title="Returns the information whether the described flow must let any other flow pass.">mustBrake</a>(fromE, toE, c.<a class="code" href="../../d5/de2/struct_n_b_edge_1_1_connection.html#a19f2e971fa08d8edaa0c4a5206b42947" title="The lane the connections yields in.">toLane</a>);
<a name="l00741"></a>00741     }
<a name="l00742"></a>00742     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00743"></a>00743 }
<a name="l00744"></a>00744 
<a name="l00745"></a>00745 
<a name="l00746"></a>00746 <span class="keywordtype">void</span>
<a name="l00747"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a8ad3cdb03cca219b37ca7329b39be1db">00747</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a8ad3cdb03cca219b37ca7329b39be1db" title="computes the node&amp;#39;s type, logic and traffic light">NBNode::computeLogic</a>(<span class="keyword">const</span> <a class="code" href="../../da/ded/class_n_b_edge_cont.html" title="Storage for edges, including some functionality operating on multiple edges.">NBEdgeCont</a>&amp; ec, <a class="code" href="../../db/d31/class_options_cont.html" title="A storage for options typed value containers).">OptionsCont</a>&amp; oc) {
<a name="l00748"></a>00748     <span class="keyword">delete</span> <a class="code" href="../../d3/dd1/class_n_b_node.html#a4db054c358db8eb749514219368f3308">myRequest</a>; <span class="comment">// possibly recomputation step</span>
<a name="l00749"></a>00749     <a class="code" href="../../d3/dd1/class_n_b_node.html#a4db054c358db8eb749514219368f3308">myRequest</a> = 0;
<a name="l00750"></a>00750     <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.size() == 0 || <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.size() == 0) {
<a name="l00751"></a>00751         <span class="comment">// no logic if nothing happens here</span>
<a name="l00752"></a>00752         <a class="code" href="../../d3/dd1/class_n_b_node.html#a4547c21e970c3ca1cdf98d20c347ffdc" title="The type of the junction.">myType</a> = <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#ab28dfb39f850f0859f8e28940b7ff60ba1bbeaa02fa0063bb67f1dcdafba01a83">NODETYPE_NOJUNCTION</a>;
<a name="l00753"></a>00753         <span class="keywordflow">return</span>;
<a name="l00754"></a>00754     }
<a name="l00755"></a>00755     <span class="comment">// check whether the node was set to be unregulated by the user</span>
<a name="l00756"></a>00756     <span class="keywordflow">if</span> (oc.<a class="code" href="../../db/d31/class_options_cont.html#a69874e7145a196b169c3c56eb58d3d57" title="Returns the boolean-value of the named option (only for Option_Bool).">getBool</a>(<span class="stringliteral">&quot;keep-nodes-unregulated&quot;</span>) || oc.<a class="code" href="../../db/d31/class_options_cont.html#a7e67fa5bc45bfc339520775679823ca8" title="Returns the named option is a list of string values containing the specified item...">isInStringVector</a>(<span class="stringliteral">&quot;keep-nodes-unregulated.explicit&quot;</span>, <a class="code" href="../../d5/dbf/class_named.html#a20fd12b55c213fd79eae9fdd47b14eb1" title="Returns the id.">getID</a>())
<a name="l00757"></a>00757             || (oc.<a class="code" href="../../db/d31/class_options_cont.html#a69874e7145a196b169c3c56eb58d3d57" title="Returns the boolean-value of the named option (only for Option_Bool).">getBool</a>(<span class="stringliteral">&quot;keep-nodes-unregulated.district-nodes&quot;</span>) &amp;&amp; (<a class="code" href="../../d3/dd1/class_n_b_node.html#a02dd480f3582912cb466098ebc60f8f2">isNearDistrict</a>() || <a class="code" href="../../d3/dd1/class_n_b_node.html#a578a65d1b86e9b9b45aa53e6132b93fa">isDistrict</a>()))) {
<a name="l00758"></a>00758         <a class="code" href="../../d3/dd1/class_n_b_node.html#a4547c21e970c3ca1cdf98d20c347ffdc" title="The type of the junction.">myType</a> = <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#ab28dfb39f850f0859f8e28940b7ff60ba1bbeaa02fa0063bb67f1dcdafba01a83">NODETYPE_NOJUNCTION</a>;
<a name="l00759"></a>00759         <span class="keywordflow">return</span>;
<a name="l00760"></a>00760     }
<a name="l00761"></a>00761     <span class="comment">// compute the logic if necessary or split the junction</span>
<a name="l00762"></a>00762     <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#a4547c21e970c3ca1cdf98d20c347ffdc" title="The type of the junction.">myType</a> != <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#ab28dfb39f850f0859f8e28940b7ff60ba1bbeaa02fa0063bb67f1dcdafba01a83">NODETYPE_NOJUNCTION</a> &amp;&amp; <a class="code" href="../../d3/dd1/class_n_b_node.html#a4547c21e970c3ca1cdf98d20c347ffdc" title="The type of the junction.">myType</a> != <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#ab28dfb39f850f0859f8e28940b7ff60bad47669f635d721ff836d08b870a9efc4">NODETYPE_DISTRICT</a>) {
<a name="l00763"></a>00763         <span class="comment">// build the request</span>
<a name="l00764"></a>00764         <a class="code" href="../../d3/dd1/class_n_b_node.html#a4db054c358db8eb749514219368f3308">myRequest</a> = <span class="keyword">new</span> <a class="code" href="../../df/d8e/class_n_b_request.html">NBRequest</a>(ec, <span class="keyword">this</span>,
<a name="l00765"></a>00765                                   <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>, <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>, <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>, <a class="code" href="../../d3/dd1/class_n_b_node.html#ac98d1cb79982c14acd078c3c5ad2df31">myBlockedConnections</a>);
<a name="l00766"></a>00766         <span class="comment">// check whether it is not too large</span>
<a name="l00767"></a>00767         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numConnections = <a class="code" href="../../d3/dd1/class_n_b_node.html#a4db054c358db8eb749514219368f3308">myRequest</a>-&gt;<a class="code" href="../../df/d8e/class_n_b_request.html#aa7ac7323a798810ea1e0abed71107422" title="returns the number of the junction&amp;#39;s lanes and the number of the junction&amp;#39;s...">getSizes</a>().second;
<a name="l00768"></a>00768         <span class="keywordflow">if</span> (numConnections &gt;= 64) {
<a name="l00769"></a>00769             <span class="comment">// yep -&gt; make it untcontrolled, warn</span>
<a name="l00770"></a>00770             <a class="code" href="../../d4/df7/_msg_handler_8h.html#a6875e463bd2d24f027eba135e7a5fdfa">WRITE_WARNING</a>(<span class="stringliteral">&quot;Junction &#39;&quot;</span> + <a class="code" href="../../d5/dbf/class_named.html#a20fd12b55c213fd79eae9fdd47b14eb1" title="Returns the id.">getID</a>() + <span class="stringliteral">&quot;&#39; is too complicated (#links&gt;64); will be set to unregulated.&quot;</span>);
<a name="l00771"></a>00771             <span class="keyword">delete</span> <a class="code" href="../../d3/dd1/class_n_b_node.html#a4db054c358db8eb749514219368f3308">myRequest</a>;
<a name="l00772"></a>00772             <a class="code" href="../../d3/dd1/class_n_b_node.html#a4db054c358db8eb749514219368f3308">myRequest</a> = 0;
<a name="l00773"></a>00773             <a class="code" href="../../d3/dd1/class_n_b_node.html#a4547c21e970c3ca1cdf98d20c347ffdc" title="The type of the junction.">myType</a> = <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#ab28dfb39f850f0859f8e28940b7ff60ba1bbeaa02fa0063bb67f1dcdafba01a83">NODETYPE_NOJUNCTION</a>;
<a name="l00774"></a>00774         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (numConnections == 0) {
<a name="l00775"></a>00775             <span class="keyword">delete</span> <a class="code" href="../../d3/dd1/class_n_b_node.html#a4db054c358db8eb749514219368f3308">myRequest</a>;
<a name="l00776"></a>00776             <a class="code" href="../../d3/dd1/class_n_b_node.html#a4db054c358db8eb749514219368f3308">myRequest</a> = 0;
<a name="l00777"></a>00777             <a class="code" href="../../d3/dd1/class_n_b_node.html#a4547c21e970c3ca1cdf98d20c347ffdc" title="The type of the junction.">myType</a> = <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#ab28dfb39f850f0859f8e28940b7ff60bac782e7d57fbac12e9f1e9b062a87a58d">NODETYPE_DEAD_END</a>;
<a name="l00778"></a>00778         } <span class="keywordflow">else</span> {
<a name="l00779"></a>00779             <a class="code" href="../../d3/dd1/class_n_b_node.html#a4db054c358db8eb749514219368f3308">myRequest</a>-&gt;<a class="code" href="../../df/d8e/class_n_b_request.html#a92ea9a24378f61a909f71d9f379ace13">buildBitfieldLogic</a>(ec.<a class="code" href="../../da/ded/class_n_b_edge_cont.html#a8e90df2ff3c1768471e69155b17df3e9" title="Returns whether the built edges are left-handed.">isLeftHanded</a>());
<a name="l00780"></a>00780         }
<a name="l00781"></a>00781     }
<a name="l00782"></a>00782 }
<a name="l00783"></a>00783 
<a name="l00784"></a>00784 
<a name="l00785"></a>00785 <span class="keywordtype">bool</span>
<a name="l00786"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a0de45f66bf53c911f5b89f16481a80c5">00786</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a0de45f66bf53c911f5b89f16481a80c5">NBNode::writeLogic</a>(<a class="code" href="../../de/da0/class_output_device.html" title="Static storage of an output device and its base (abstract) implementation.">OutputDevice</a>&amp; into)<span class="keyword"> const </span>{
<a name="l00787"></a>00787     <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#a4db054c358db8eb749514219368f3308">myRequest</a>) {
<a name="l00788"></a>00788         <a class="code" href="../../d3/dd1/class_n_b_node.html#a4db054c358db8eb749514219368f3308">myRequest</a>-&gt;<a class="code" href="../../df/d8e/class_n_b_request.html#acbaa56062d003093d05cbe0c2047af06">writeLogic</a>(<a class="code" href="../../d5/dbf/class_named.html#a1c4c561f94309ed24571ddc8baa9370a" title="The name of the object.">myID</a>, into);
<a name="l00789"></a>00789         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00790"></a>00790     }
<a name="l00791"></a>00791     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00792"></a>00792 }
<a name="l00793"></a>00793 
<a name="l00794"></a>00794 
<a name="l00795"></a>00795 <span class="keywordtype">void</span>
<a name="l00796"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#abca9d6227c80399abf076748d7d19cab">00796</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#abca9d6227c80399abf076748d7d19cab">NBNode::sortNodesEdges</a>(<span class="keywordtype">bool</span> leftHand) {
<a name="l00797"></a>00797     <span class="comment">// sort the edges</span>
<a name="l00798"></a>00798     sort(<a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.begin(), <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.end(), <a class="code" href="../../df/d1c/class_n_b_cont_helper_1_1edge__by__junction__angle__sorter.html">NBContHelper::edge_by_junction_angle_sorter</a>(<span class="keyword">this</span>));
<a name="l00799"></a>00799     sort(<a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.begin(), <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.end(), <a class="code" href="../../df/d1c/class_n_b_cont_helper_1_1edge__by__junction__angle__sorter.html">NBContHelper::edge_by_junction_angle_sorter</a>(<span class="keyword">this</span>));
<a name="l00800"></a>00800     sort(<a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.begin(), <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.end(), <a class="code" href="../../df/d1c/class_n_b_cont_helper_1_1edge__by__junction__angle__sorter.html">NBContHelper::edge_by_junction_angle_sorter</a>(<span class="keyword">this</span>));
<a name="l00801"></a>00801     <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.size() == 0) {
<a name="l00802"></a>00802         <span class="keywordflow">return</span>;
<a name="l00803"></a>00803     }
<a name="l00804"></a>00804     EdgeVector::iterator i;
<a name="l00805"></a>00805     <span class="keywordflow">for</span> (i = <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.begin(); i != <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.end() - 1 &amp;&amp; i != <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.end(); i++) {
<a name="l00806"></a>00806         <a class="code" href="../../d3/dd1/class_n_b_node.html#a129eb304910fd02352850a7b16df67d8">swapWhenReversed</a>(leftHand , i, i + 1);
<a name="l00807"></a>00807     }
<a name="l00808"></a>00808     <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.size() &gt; 1 &amp;&amp; i != <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.end()) {
<a name="l00809"></a>00809         <a class="code" href="../../d3/dd1/class_n_b_node.html#a129eb304910fd02352850a7b16df67d8">swapWhenReversed</a>(leftHand, <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.end() - 1, <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.begin());
<a name="l00810"></a>00810     }
<a name="l00811"></a>00811 }
<a name="l00812"></a>00812 
<a name="l00813"></a>00813 
<a name="l00814"></a>00814 <span class="keywordtype">void</span>
<a name="l00815"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#afb95371a3ae6a52b09508723233bea82">00815</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#afb95371a3ae6a52b09508723233bea82">NBNode::computeNodeShape</a>(<span class="keywordtype">bool</span> leftHand) {
<a name="l00816"></a>00816     <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.size() == 0 &amp;&amp; <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.size() == 0) {
<a name="l00817"></a>00817         <span class="keywordflow">return</span>;
<a name="l00818"></a>00818     }
<a name="l00819"></a>00819     <span class="keywordflow">try</span> {
<a name="l00820"></a>00820         <a class="code" href="../../d4/d4f/class_n_b_node_shape_computer.html" title="This class computes shapes of junctions.">NBNodeShapeComputer</a> computer(*<span class="keyword">this</span>);
<a name="l00821"></a>00821         <a class="code" href="../../d3/dd1/class_n_b_node.html#ae698ead9f7c0e5205646ebec2839c8bc" title="the (outer) shape of the junction">myPoly</a> = computer.<a class="code" href="../../d4/d4f/class_n_b_node_shape_computer.html#a2807b054fe27231e0055c85fe85af839" title="Computes the shape of the assigned junction.">compute</a>(leftHand);
<a name="l00822"></a>00822     } <span class="keywordflow">catch</span> (<a class="code" href="../../d3/d68/class_invalid_argument.html">InvalidArgument</a>&amp;) {
<a name="l00823"></a>00823         <a class="code" href="../../d4/df7/_msg_handler_8h.html#a6875e463bd2d24f027eba135e7a5fdfa">WRITE_WARNING</a>(<span class="stringliteral">&quot;For node &#39;&quot;</span> + <a class="code" href="../../d5/dbf/class_named.html#a20fd12b55c213fd79eae9fdd47b14eb1" title="Returns the id.">getID</a>() + <span class="stringliteral">&quot;&#39;: could not compute shape.&quot;</span>);
<a name="l00824"></a>00824     }
<a name="l00825"></a>00825 }
<a name="l00826"></a>00826 
<a name="l00827"></a>00827 
<a name="l00828"></a>00828 <span class="keywordtype">void</span>
<a name="l00829"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#ab84dcd60e03a9d30b8b58be9cf10b453">00829</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#ab84dcd60e03a9d30b8b58be9cf10b453" title="computes the connections of lanes to edges">NBNode::computeLanes2Lanes</a>() {
<a name="l00830"></a>00830     <span class="comment">// special case a):</span>
<a name="l00831"></a>00831     <span class="comment">//  one in, one out, the outgoing has one lane more</span>
<a name="l00832"></a>00832     <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.size() == 1 &amp;&amp; <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.size() == 1
<a name="l00833"></a>00833             &amp;&amp; <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>[0]-&gt;getNumLanes() == <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>[0]-&gt;getNumLanes() - 1
<a name="l00834"></a>00834             &amp;&amp; <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>[0] != <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>[0]
<a name="l00835"></a>00835             &amp;&amp; <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>[0]-&gt;isConnectedTo(<a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>[0])) {
<a name="l00836"></a>00836 
<a name="l00837"></a>00837         <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* incoming = <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>[0];
<a name="l00838"></a>00838         <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* outgoing = <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>[0];
<a name="l00839"></a>00839         <span class="comment">// check if it&#39;s not the turnaround</span>
<a name="l00840"></a>00840         <span class="keywordflow">if</span> (incoming-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#a4acf76dc68775ec29767a43e95c907aa">getTurnDestination</a>() == outgoing) {
<a name="l00841"></a>00841             <span class="comment">// will be added later or not...</span>
<a name="l00842"></a>00842             <span class="keywordflow">return</span>;
<a name="l00843"></a>00843         }
<a name="l00844"></a>00844         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (int) incoming-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#aa6ed274bbffc247a43e91a8ec4b150a1" title="Returns the number of lanes.">getNumLanes</a>(); ++i) {
<a name="l00845"></a>00845             incoming-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#a8d3b7f259e08624e58f593c5442553e6" title="Adds a connection to a certain lane of a certain edge.">setConnection</a>(i, outgoing, i + 1, <a class="code" href="../../d7/d41/class_n_b_edge.html#aa1576d07471ecc008d626cdbfb3302f2ae74f722fd0b9fd70b73c22135afd90f9" title="The connection was computed.">NBEdge::L2L_COMPUTED</a>);
<a name="l00846"></a>00846         }
<a name="l00847"></a>00847         incoming-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#a8d3b7f259e08624e58f593c5442553e6" title="Adds a connection to a certain lane of a certain edge.">setConnection</a>(0, outgoing, 0, <a class="code" href="../../d7/d41/class_n_b_edge.html#aa1576d07471ecc008d626cdbfb3302f2ae74f722fd0b9fd70b73c22135afd90f9" title="The connection was computed.">NBEdge::L2L_COMPUTED</a>);
<a name="l00848"></a>00848         <span class="keywordflow">return</span>;
<a name="l00849"></a>00849     }
<a name="l00850"></a>00850     <span class="comment">// special case b):</span>
<a name="l00851"></a>00851     <span class="comment">//  two in, one out, the outgoing has the same number of lanes as the sum of the incoming</span>
<a name="l00852"></a>00852     <span class="comment">//  and a high speed, too</span>
<a name="l00853"></a>00853     <span class="comment">//  --&gt; highway on-ramp</span>
<a name="l00854"></a>00854     <span class="keywordtype">bool</span> check = <span class="keyword">false</span>;
<a name="l00855"></a>00855     <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.size() == 2 &amp;&amp; <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.size() == 1) {
<a name="l00856"></a>00856         check = <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>[0]-&gt;getNumLanes() + <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>[1]-&gt;getNumLanes() == <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>[0]-&gt;getNumLanes();
<a name="l00857"></a>00857         check &amp;= (<a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>[0]-&gt;getStep() &lt;= <a class="code" href="../../d7/d41/class_n_b_edge.html#a5f800e73a3f8ada2114981754cfbbc86abb320a97a177a4bf1fbf0105f6e0a6c8" title="Lanes to edges - relationships are computed/loaded.">NBEdge::LANES2EDGES</a>);
<a name="l00858"></a>00858         check &amp;= (<a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>[1]-&gt;getStep() &lt;= <a class="code" href="../../d7/d41/class_n_b_edge.html#a5f800e73a3f8ada2114981754cfbbc86abb320a97a177a4bf1fbf0105f6e0a6c8" title="Lanes to edges - relationships are computed/loaded.">NBEdge::LANES2EDGES</a>);
<a name="l00859"></a>00859     }
<a name="l00860"></a>00860     <span class="keywordflow">if</span> (check
<a name="l00861"></a>00861             &amp;&amp; <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>[0] != <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>[0]
<a name="l00862"></a>00862             &amp;&amp; <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>[0]-&gt;isConnectedTo(<a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>[0])) {
<a name="l00863"></a>00863         <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* inc1 = <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>[0];
<a name="l00864"></a>00864         <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* inc2 = <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>[1];
<a name="l00865"></a>00865         <span class="comment">// for internal: check which one is the rightmost</span>
<a name="l00866"></a>00866         <a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a> a1 = inc1-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#a35a4bbaea9501ed0a2cd38a7f97b7086" title="Returns the angle of the edge.">getAngle</a>(*<span class="keyword">this</span>);
<a name="l00867"></a>00867         <a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a> a2 = inc2-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#a35a4bbaea9501ed0a2cd38a7f97b7086" title="Returns the angle of the edge.">getAngle</a>(*<span class="keyword">this</span>);
<a name="l00868"></a>00868         <a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a> ccw = <a class="code" href="../../d3/de6/class_geom_helper.html#a284494c179d675ac51b2593c1b2532ee" title="Returns the distance of second angle from first angle counter-clockwise.">GeomHelper::getCCWAngleDiff</a>(a1, a2);
<a name="l00869"></a>00869         <a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a> cw = <a class="code" href="../../d3/de6/class_geom_helper.html#aa66a4be03e23596f7d6539529b52a0a6" title="Returns the distance of second angle from first angle clockwise.">GeomHelper::getCWAngleDiff</a>(a1, a2);
<a name="l00870"></a>00870         <span class="keywordflow">if</span> (ccw &lt; cw) {
<a name="l00871"></a>00871             std::swap(inc1, inc2);
<a name="l00872"></a>00872         }
<a name="l00873"></a>00873         <span class="comment">//</span>
<a name="l00874"></a>00874         inc1-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#a47ba9d1aeebff4be79cf074fb586f85c" title="Builds no connections starting at the given lanes.">addLane2LaneConnections</a>(0, <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>[0], 0, inc1-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#aa6ed274bbffc247a43e91a8ec4b150a1" title="Returns the number of lanes.">getNumLanes</a>(), <a class="code" href="../../d7/d41/class_n_b_edge.html#aa1576d07471ecc008d626cdbfb3302f2aba63868f28825735eb91856ff5ae804c" title="The connection was computed and validated.">NBEdge::L2L_VALIDATED</a>, <span class="keyword">true</span>, <span class="keyword">true</span>);
<a name="l00875"></a>00875         inc2-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#a47ba9d1aeebff4be79cf074fb586f85c" title="Builds no connections starting at the given lanes.">addLane2LaneConnections</a>(0, <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>[0], inc1-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#aa6ed274bbffc247a43e91a8ec4b150a1" title="Returns the number of lanes.">getNumLanes</a>(), inc2-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#aa6ed274bbffc247a43e91a8ec4b150a1" title="Returns the number of lanes.">getNumLanes</a>(), <a class="code" href="../../d7/d41/class_n_b_edge.html#aa1576d07471ecc008d626cdbfb3302f2aba63868f28825735eb91856ff5ae804c" title="The connection was computed and validated.">NBEdge::L2L_VALIDATED</a>, <span class="keyword">true</span>, <span class="keyword">true</span>);
<a name="l00876"></a>00876         <span class="keywordflow">return</span>;
<a name="l00877"></a>00877     }
<a name="l00878"></a>00878 
<a name="l00879"></a>00879     <span class="comment">// go through this node&#39;s outgoing edges</span>
<a name="l00880"></a>00880     <span class="comment">//  for every outgoing edge, compute the distribution of the node&#39;s</span>
<a name="l00881"></a>00881     <span class="comment">//  incoming edges on this edge when approaching this edge</span>
<a name="l00882"></a>00882     <span class="comment">// the incoming edges&#39; steps will then also be marked as LANE2LANE_RECHECK...</span>
<a name="l00883"></a>00883     EdgeVector::reverse_iterator i;
<a name="l00884"></a>00884     <span class="keywordflow">for</span> (i = <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.rbegin(); i != <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.rend(); i++) {
<a name="l00885"></a>00885         <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* currentOutgoing = *i;
<a name="l00886"></a>00886         <span class="comment">// get the information about edges that do approach this edge</span>
<a name="l00887"></a>00887         <a class="code" href="../../db/dde/_n_b_cont_8h.html#a7bbd80497f8b27f18697210825ec974a">EdgeVector</a>* approaching = <a class="code" href="../../d3/dd1/class_n_b_node.html#a8037c7602ce276c483e449a552af8dd2">getEdgesThatApproach</a>(currentOutgoing);
<a name="l00888"></a>00888         <span class="keywordflow">if</span> (approaching-&gt;size() != 0) {
<a name="l00889"></a>00889             <a class="code" href="../../d5/dc7/class_n_b_node_1_1_approaching_divider.html" title="Computes lane-2-lane connections.">ApproachingDivider</a> divider(approaching, currentOutgoing);
<a name="l00890"></a>00890             <a class="code" href="../../d9/dad/class_bresenham.html#a0d3de2eda32a0a987fad0e099692aa83">Bresenham::compute</a>(&amp;divider, static_cast&lt;unsigned int&gt;(approaching-&gt;size()),
<a name="l00891"></a>00891                                currentOutgoing-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#aa6ed274bbffc247a43e91a8ec4b150a1" title="Returns the number of lanes.">getNumLanes</a>());
<a name="l00892"></a>00892         }
<a name="l00893"></a>00893         <span class="keyword">delete</span> approaching;
<a name="l00894"></a>00894     }
<a name="l00895"></a>00895     <span class="comment">// ... but we may have the case that there are no outgoing edges</span>
<a name="l00896"></a>00896     <span class="comment">//  In this case, we have to mark the incoming edges as being in state</span>
<a name="l00897"></a>00897     <span class="comment">//   LANE2LANE( not RECHECK) by hand</span>
<a name="l00898"></a>00898     <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.size() == 0) {
<a name="l00899"></a>00899         <span class="keywordflow">for</span> (i = <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.rbegin(); i != <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.rend(); i++) {
<a name="l00900"></a>00900             (*i)-&gt;markAsInLane2LaneState();
<a name="l00901"></a>00901         }
<a name="l00902"></a>00902     }
<a name="l00903"></a>00903 }
<a name="l00904"></a>00904 
<a name="l00905"></a>00905 
<a name="l00906"></a>00906 <a class="code" href="../../db/dde/_n_b_cont_8h.html#a7bbd80497f8b27f18697210825ec974a">EdgeVector</a>*
<a name="l00907"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a8037c7602ce276c483e449a552af8dd2">00907</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a8037c7602ce276c483e449a552af8dd2">NBNode::getEdgesThatApproach</a>(<a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* currentOutgoing) {
<a name="l00908"></a>00908     <span class="comment">// get the position of the node to get the approaching nodes of</span>
<a name="l00909"></a>00909     EdgeVector::const_iterator i = find(<a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.begin(),
<a name="l00910"></a>00910                                         <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.end(), currentOutgoing);
<a name="l00911"></a>00911     <span class="comment">// get the first possible approaching edge</span>
<a name="l00912"></a>00912     <a class="code" href="../../df/d78/class_n_b_cont_helper.html#a27ff78c70d9a3f11b7dafd6f2bab51ee">NBContHelper::nextCW</a>(<a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>, i);
<a name="l00913"></a>00913     <span class="comment">// go through the list of edges clockwise and add the edges</span>
<a name="l00914"></a>00914     <a class="code" href="../../db/dde/_n_b_cont_8h.html#a7bbd80497f8b27f18697210825ec974a">EdgeVector</a>* approaching = <span class="keyword">new</span> <a class="code" href="../../db/dde/_n_b_cont_8h.html#a7bbd80497f8b27f18697210825ec974a">EdgeVector</a>();
<a name="l00915"></a>00915     <span class="keywordflow">for</span> (; *i != currentOutgoing;) {
<a name="l00916"></a>00916         <span class="comment">// check only incoming edges</span>
<a name="l00917"></a>00917         <span class="keywordflow">if</span> ((*i)-&gt;getToNode() == <span class="keyword">this</span> &amp;&amp; (*i)-&gt;getTurnDestination() != currentOutgoing) {
<a name="l00918"></a>00918             std::vector&lt;int&gt; connLanes = (*i)-&gt;getConnectionLanes(currentOutgoing);
<a name="l00919"></a>00919             <span class="keywordflow">if</span> (connLanes.size() != 0) {
<a name="l00920"></a>00920                 approaching-&gt;push_back(*i);
<a name="l00921"></a>00921             }
<a name="l00922"></a>00922         }
<a name="l00923"></a>00923         NBContHelper::nextCW(<a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>, i);
<a name="l00924"></a>00924     }
<a name="l00925"></a>00925     <span class="keywordflow">return</span> approaching;
<a name="l00926"></a>00926 }
<a name="l00927"></a>00927 
<a name="l00928"></a>00928 
<a name="l00929"></a>00929 <span class="keywordtype">void</span>
<a name="l00930"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a3503004d7ea2a1a35cdc3513e195bfca">00930</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a3503004d7ea2a1a35cdc3513e195bfca" title="Replaces occurences of the first edge within the list of outgoing by the second Connections...">NBNode::replaceOutgoing</a>(<a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* which, <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* by, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> laneOff) {
<a name="l00931"></a>00931     <span class="comment">// replace the edge in the list of outgoing nodes</span>
<a name="l00932"></a>00932     EdgeVector::iterator i = find(<a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.begin(), <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.end(), which);
<a name="l00933"></a>00933     <span class="keywordflow">if</span> (i != <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.end()) {
<a name="l00934"></a>00934         (*i) = by;
<a name="l00935"></a>00935         i = find(<a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.begin(), <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.end(), which);
<a name="l00936"></a>00936         (*i) = by;
<a name="l00937"></a>00937     }
<a name="l00938"></a>00938     <span class="comment">// replace the edge in connections of incoming edges</span>
<a name="l00939"></a>00939     <span class="keywordflow">for</span> (i = <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.begin(); i != <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.end(); ++i) {
<a name="l00940"></a>00940         (*i)-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#ad38b999bd1027ca966d5e78d515b030d">replaceInConnections</a>(which, by, laneOff);
<a name="l00941"></a>00941     }
<a name="l00942"></a>00942     <span class="comment">// replace within the connetion prohibition dependencies</span>
<a name="l00943"></a>00943     <a class="code" href="../../d3/dd1/class_n_b_node.html#abe87576f54f11a782f2372c7539f1162">replaceInConnectionProhibitions</a>(which, by, 0, laneOff);
<a name="l00944"></a>00944 }
<a name="l00945"></a>00945 
<a name="l00946"></a>00946 
<a name="l00947"></a>00947 <span class="keywordtype">void</span>
<a name="l00948"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a173dd7f50ddb687b979f1b7cd2876e6a">00948</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a3503004d7ea2a1a35cdc3513e195bfca" title="Replaces occurences of the first edge within the list of outgoing by the second Connections...">NBNode::replaceOutgoing</a>(<span class="keyword">const</span> <a class="code" href="../../db/dde/_n_b_cont_8h.html#a7bbd80497f8b27f18697210825ec974a">EdgeVector</a>&amp; which, <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* by) {
<a name="l00949"></a>00949     <span class="comment">// replace edges</span>
<a name="l00950"></a>00950     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> laneOff = 0;
<a name="l00951"></a>00951     <span class="keywordflow">for</span> (EdgeVector::const_iterator i = which.begin(); i != which.end(); i++) {
<a name="l00952"></a>00952         <a class="code" href="../../d3/dd1/class_n_b_node.html#a3503004d7ea2a1a35cdc3513e195bfca" title="Replaces occurences of the first edge within the list of outgoing by the second Connections...">replaceOutgoing</a>(*i, by, laneOff);
<a name="l00953"></a>00953         laneOff += (*i)-&gt;getNumLanes();
<a name="l00954"></a>00954     }
<a name="l00955"></a>00955     <span class="comment">// removed SUMOReal occurences</span>
<a name="l00956"></a>00956     <a class="code" href="../../d3/dd1/class_n_b_node.html#ae04b5d06eeaf195613555eb8a14228fc">removeDoubleEdges</a>();
<a name="l00957"></a>00957     <span class="comment">// check whether this node belongs to a district and the edges</span>
<a name="l00958"></a>00958     <span class="comment">//  must here be also remapped</span>
<a name="l00959"></a>00959     <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#ab5565e3d9d3aaa3d6520acfb95f497c0" title="The district the node is the centre of.">myDistrict</a> != 0) {
<a name="l00960"></a>00960         <a class="code" href="../../d3/dd1/class_n_b_node.html#ab5565e3d9d3aaa3d6520acfb95f497c0" title="The district the node is the centre of.">myDistrict</a>-&gt;<a class="code" href="../../d7/d91/class_n_b_district.html#a4f528982adc6bd85dd00652d824923b2" title="Replaces outgoing edges from the vector (source) by the given edge.">replaceOutgoing</a>(which, by);
<a name="l00961"></a>00961     }
<a name="l00962"></a>00962 }
<a name="l00963"></a>00963 
<a name="l00964"></a>00964 
<a name="l00965"></a>00965 <span class="keywordtype">void</span>
<a name="l00966"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a3246b849700a2347a8e2297c8c0752a8">00966</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a3246b849700a2347a8e2297c8c0752a8" title="Replaces occurences of the first edge within the list of incoming by the second Connections...">NBNode::replaceIncoming</a>(<a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* which, <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* by, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> laneOff) {
<a name="l00967"></a>00967     <span class="comment">// replace the edge in the list of incoming nodes</span>
<a name="l00968"></a>00968     EdgeVector::iterator i = find(<a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.begin(), <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.end(), which);
<a name="l00969"></a>00969     <span class="keywordflow">if</span> (i != <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.end()) {
<a name="l00970"></a>00970         (*i) = by;
<a name="l00971"></a>00971         i = find(<a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.begin(), <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.end(), which);
<a name="l00972"></a>00972         (*i) = by;
<a name="l00973"></a>00973     }
<a name="l00974"></a>00974     <span class="comment">// replace within the connetion prohibition dependencies</span>
<a name="l00975"></a>00975     <a class="code" href="../../d3/dd1/class_n_b_node.html#abe87576f54f11a782f2372c7539f1162">replaceInConnectionProhibitions</a>(which, by, laneOff, 0);
<a name="l00976"></a>00976 }
<a name="l00977"></a>00977 
<a name="l00978"></a>00978 
<a name="l00979"></a>00979 <span class="keywordtype">void</span>
<a name="l00980"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a79acb8f2c5b61aaf4ada36c326e503c8">00980</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a3246b849700a2347a8e2297c8c0752a8" title="Replaces occurences of the first edge within the list of incoming by the second Connections...">NBNode::replaceIncoming</a>(<span class="keyword">const</span> <a class="code" href="../../db/dde/_n_b_cont_8h.html#a7bbd80497f8b27f18697210825ec974a">EdgeVector</a>&amp; which, <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* by) {
<a name="l00981"></a>00981     <span class="comment">// replace edges</span>
<a name="l00982"></a>00982     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> laneOff = 0;
<a name="l00983"></a>00983     <span class="keywordflow">for</span> (EdgeVector::const_iterator i = which.begin(); i != which.end(); i++) {
<a name="l00984"></a>00984         <a class="code" href="../../d3/dd1/class_n_b_node.html#a3246b849700a2347a8e2297c8c0752a8" title="Replaces occurences of the first edge within the list of incoming by the second Connections...">replaceIncoming</a>(*i, by, laneOff);
<a name="l00985"></a>00985         laneOff += (*i)-&gt;getNumLanes();
<a name="l00986"></a>00986     }
<a name="l00987"></a>00987     <span class="comment">// removed SUMOReal occurences</span>
<a name="l00988"></a>00988     <a class="code" href="../../d3/dd1/class_n_b_node.html#ae04b5d06eeaf195613555eb8a14228fc">removeDoubleEdges</a>();
<a name="l00989"></a>00989     <span class="comment">// check whether this node belongs to a district and the edges</span>
<a name="l00990"></a>00990     <span class="comment">//  must here be also remapped</span>
<a name="l00991"></a>00991     <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#ab5565e3d9d3aaa3d6520acfb95f497c0" title="The district the node is the centre of.">myDistrict</a> != 0) {
<a name="l00992"></a>00992         <a class="code" href="../../d3/dd1/class_n_b_node.html#ab5565e3d9d3aaa3d6520acfb95f497c0" title="The district the node is the centre of.">myDistrict</a>-&gt;<a class="code" href="../../d7/d91/class_n_b_district.html#a3759bc4e536e93074c9c08287cbbe1fe" title="Replaces incoming edges from the vector (sinks) by the given edge.">replaceIncoming</a>(which, by);
<a name="l00993"></a>00993     }
<a name="l00994"></a>00994 }
<a name="l00995"></a>00995 
<a name="l00996"></a>00996 
<a name="l00997"></a>00997 
<a name="l00998"></a>00998 <span class="keywordtype">void</span>
<a name="l00999"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#abe87576f54f11a782f2372c7539f1162">00999</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#abe87576f54f11a782f2372c7539f1162">NBNode::replaceInConnectionProhibitions</a>(<a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* which, <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* by,
<a name="l01000"></a>01000                                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> whichLaneOff, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> byLaneOff) {
<a name="l01001"></a>01001     <span class="comment">// replace in keys</span>
<a name="l01002"></a>01002     NBConnectionProhibits::iterator j = <a class="code" href="../../d3/dd1/class_n_b_node.html#ac98d1cb79982c14acd078c3c5ad2df31">myBlockedConnections</a>.begin();
<a name="l01003"></a>01003     <span class="keywordflow">while</span> (j != <a class="code" href="../../d3/dd1/class_n_b_node.html#ac98d1cb79982c14acd078c3c5ad2df31">myBlockedConnections</a>.end()) {
<a name="l01004"></a>01004         <span class="keywordtype">bool</span> changed = <span class="keyword">false</span>;
<a name="l01005"></a>01005         <a class="code" href="../../dc/d41/class_n_b_connection.html">NBConnection</a> c = (*j).first;
<a name="l01006"></a>01006         <span class="keywordflow">if</span> (c.<a class="code" href="../../dc/d41/class_n_b_connection.html#a759032c7221a0ec81f0ac8d62d660584" title="replaces the from-edge by the one given">replaceFrom</a>(which, whichLaneOff, by, byLaneOff)) {
<a name="l01007"></a>01007             changed = <span class="keyword">true</span>;
<a name="l01008"></a>01008         }
<a name="l01009"></a>01009         <span class="keywordflow">if</span> (c.<a class="code" href="../../dc/d41/class_n_b_connection.html#a33c2327503c444edcd6d983af762014c" title="replaces the to-edge by the one given">replaceTo</a>(which, whichLaneOff, by, byLaneOff)) {
<a name="l01010"></a>01010             changed = <span class="keyword">true</span>;
<a name="l01011"></a>01011         }
<a name="l01012"></a>01012         <span class="keywordflow">if</span> (changed) {
<a name="l01013"></a>01013             <a class="code" href="../../d3/dd1/class_n_b_node.html#ac98d1cb79982c14acd078c3c5ad2df31">myBlockedConnections</a>[c] = (*j).second;
<a name="l01014"></a>01014             <a class="code" href="../../d3/dd1/class_n_b_node.html#ac98d1cb79982c14acd078c3c5ad2df31">myBlockedConnections</a>.erase(j);
<a name="l01015"></a>01015             j = <a class="code" href="../../d3/dd1/class_n_b_node.html#ac98d1cb79982c14acd078c3c5ad2df31">myBlockedConnections</a>.begin();
<a name="l01016"></a>01016         } <span class="keywordflow">else</span> {
<a name="l01017"></a>01017             j++;
<a name="l01018"></a>01018         }
<a name="l01019"></a>01019     }
<a name="l01020"></a>01020     <span class="comment">// replace in values</span>
<a name="l01021"></a>01021     <span class="keywordflow">for</span> (j = <a class="code" href="../../d3/dd1/class_n_b_node.html#ac98d1cb79982c14acd078c3c5ad2df31">myBlockedConnections</a>.begin(); j != <a class="code" href="../../d3/dd1/class_n_b_node.html#ac98d1cb79982c14acd078c3c5ad2df31">myBlockedConnections</a>.end(); j++) {
<a name="l01022"></a>01022         <a class="code" href="../../d4/d25/_n_b_connection_defs_8h.html#a5f0b6da942b048c8a727854f34530400" title="Definition of a connection vector.">NBConnectionVector</a>&amp; prohibiting = (*j).second;
<a name="l01023"></a>01023         <span class="keywordflow">for</span> (NBConnectionVector::iterator k = prohibiting.begin(); k != prohibiting.end(); k++) {
<a name="l01024"></a>01024             <a class="code" href="../../dc/d41/class_n_b_connection.html">NBConnection</a>&amp; sprohibiting = *k;
<a name="l01025"></a>01025             sprohibiting.<a class="code" href="../../dc/d41/class_n_b_connection.html#a759032c7221a0ec81f0ac8d62d660584" title="replaces the from-edge by the one given">replaceFrom</a>(which, whichLaneOff, by, byLaneOff);
<a name="l01026"></a>01026             sprohibiting.<a class="code" href="../../dc/d41/class_n_b_connection.html#a33c2327503c444edcd6d983af762014c" title="replaces the to-edge by the one given">replaceTo</a>(which, whichLaneOff, by, byLaneOff);
<a name="l01027"></a>01027         }
<a name="l01028"></a>01028     }
<a name="l01029"></a>01029 }
<a name="l01030"></a>01030 
<a name="l01031"></a>01031 
<a name="l01032"></a>01032 
<a name="l01033"></a>01033 <span class="keywordtype">void</span>
<a name="l01034"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#ae04b5d06eeaf195613555eb8a14228fc">01034</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#ae04b5d06eeaf195613555eb8a14228fc">NBNode::removeDoubleEdges</a>() {
<a name="l01035"></a>01035     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i, j;
<a name="l01036"></a>01036     <span class="comment">// check incoming</span>
<a name="l01037"></a>01037     <span class="keywordflow">for</span> (i = 0; <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.size() &gt; 0 &amp;&amp; i &lt; <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.size() - 1; i++) {
<a name="l01038"></a>01038         j = i + 1;
<a name="l01039"></a>01039         <span class="keywordflow">while</span> (j &lt; <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.size()) {
<a name="l01040"></a>01040             <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>[i] == <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>[j]) {
<a name="l01041"></a>01041                 <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.erase(<a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.begin() + j);
<a name="l01042"></a>01042             } <span class="keywordflow">else</span> {
<a name="l01043"></a>01043                 j++;
<a name="l01044"></a>01044             }
<a name="l01045"></a>01045         }
<a name="l01046"></a>01046     }
<a name="l01047"></a>01047     <span class="comment">// check outgoing</span>
<a name="l01048"></a>01048     <span class="keywordflow">for</span> (i = 0; <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.size() &gt; 0 &amp;&amp; i &lt; <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.size() - 1; i++) {
<a name="l01049"></a>01049         j = i + 1;
<a name="l01050"></a>01050         <span class="keywordflow">while</span> (j &lt; <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.size()) {
<a name="l01051"></a>01051             <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>[i] == <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>[j]) {
<a name="l01052"></a>01052                 <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.erase(<a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.begin() + j);
<a name="l01053"></a>01053             } <span class="keywordflow">else</span> {
<a name="l01054"></a>01054                 j++;
<a name="l01055"></a>01055             }
<a name="l01056"></a>01056         }
<a name="l01057"></a>01057     }
<a name="l01058"></a>01058     <span class="comment">// check all</span>
<a name="l01059"></a>01059     <span class="keywordflow">for</span> (i = 0; <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.size() &gt; 0 &amp;&amp; i &lt; <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.size() - 1; i++) {
<a name="l01060"></a>01060         j = i + 1;
<a name="l01061"></a>01061         <span class="keywordflow">while</span> (j &lt; <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.size()) {
<a name="l01062"></a>01062             <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>[i] == <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>[j]) {
<a name="l01063"></a>01063                 <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.erase(<a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.begin() + j);
<a name="l01064"></a>01064             } <span class="keywordflow">else</span> {
<a name="l01065"></a>01065                 j++;
<a name="l01066"></a>01066             }
<a name="l01067"></a>01067         }
<a name="l01068"></a>01068     }
<a name="l01069"></a>01069 }
<a name="l01070"></a>01070 
<a name="l01071"></a>01071 
<a name="l01072"></a>01072 <span class="keywordtype">bool</span>
<a name="l01073"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a386dcd34fa654a46a77992b1291fe66f">01073</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a386dcd34fa654a46a77992b1291fe66f" title="Returns whether the given edge ends at this node.">NBNode::hasIncoming</a>(<span class="keyword">const</span> <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* <span class="keyword">const</span> e)<span class="keyword"> const </span>{
<a name="l01074"></a>01074     <span class="keywordflow">return</span> find(<a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.begin(), <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.end(), e) != <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.end();
<a name="l01075"></a>01075 }
<a name="l01076"></a>01076 
<a name="l01077"></a>01077 
<a name="l01078"></a>01078 <span class="keywordtype">bool</span>
<a name="l01079"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a082d27c0dcdc09d2de15a04ccc0489d5">01079</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a082d27c0dcdc09d2de15a04ccc0489d5" title="Returns whether the given edge starts at this node.">NBNode::hasOutgoing</a>(<span class="keyword">const</span> <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* <span class="keyword">const</span> e)<span class="keyword"> const </span>{
<a name="l01080"></a>01080     <span class="keywordflow">return</span> find(<a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.begin(), <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.end(), e) != <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.end();
<a name="l01081"></a>01081 }
<a name="l01082"></a>01082 
<a name="l01083"></a>01083 
<a name="l01084"></a>01084 <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>*
<a name="l01085"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a08b9d7171d43008a27c5443a5275966a">01085</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a08b9d7171d43008a27c5443a5275966a">NBNode::getOppositeIncoming</a>(<a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* e)<span class="keyword"> const </span>{
<a name="l01086"></a>01086     <a class="code" href="../../db/dde/_n_b_cont_8h.html#a7bbd80497f8b27f18697210825ec974a">EdgeVector</a> edges = <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>;
<a name="l01087"></a>01087     <span class="keywordflow">if</span> (find(edges.begin(), edges.end(), e) != edges.end()) {
<a name="l01088"></a>01088         edges.erase(find(edges.begin(), edges.end(), e));
<a name="l01089"></a>01089     }
<a name="l01090"></a>01090     <span class="keywordflow">if</span> (e-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#a47de8fb27ded13ba7886218da6b9a60f" title="Returns the destination node of the edge.">getToNode</a>() == <span class="keyword">this</span>) {
<a name="l01091"></a>01091         sort(edges.begin(), edges.end(), <a class="code" href="../../d8/d3c/class_n_b_cont_helper_1_1edge__opposite__direction__sorter.html" title="Class to sort edges by their angle in relation to the given edge.">NBContHelper::edge_opposite_direction_sorter</a>(e, <span class="keyword">this</span>));
<a name="l01092"></a>01092     } <span class="keywordflow">else</span> {
<a name="l01093"></a>01093         sort(edges.begin(), edges.end(), <a class="code" href="../../d1/d58/class_n_b_cont_helper_1_1edge__similar__direction__sorter.html">NBContHelper::edge_similar_direction_sorter</a>(e));
<a name="l01094"></a>01094     }
<a name="l01095"></a>01095     <span class="keywordflow">return</span> edges[0];
<a name="l01096"></a>01096 }
<a name="l01097"></a>01097 
<a name="l01098"></a>01098 
<a name="l01099"></a>01099 <span class="keywordtype">void</span>
<a name="l01100"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#aa1a1876ff3b6e92a49b9d3e64f51f468">01100</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#aa1a1876ff3b6e92a49b9d3e64f51f468">NBNode::addSortedLinkFoes</a>(<span class="keyword">const</span> <a class="code" href="../../dc/d41/class_n_b_connection.html">NBConnection</a>&amp; mayDrive,
<a name="l01101"></a>01101                           <span class="keyword">const</span> <a class="code" href="../../dc/d41/class_n_b_connection.html">NBConnection</a>&amp; mustStop) {
<a name="l01102"></a>01102     <span class="keywordflow">if</span> (mayDrive.<a class="code" href="../../dc/d41/class_n_b_connection.html#ad98eb5a1de393ce3a76c510efeb31756" title="returns the from-edge (start of the connection)">getFrom</a>() == 0 ||
<a name="l01103"></a>01103             mayDrive.<a class="code" href="../../dc/d41/class_n_b_connection.html#a74ce42681b534f4095ae9ccdb3581542" title="returns the to-edge (end of the connection)">getTo</a>() == 0 ||
<a name="l01104"></a>01104             mustStop.<a class="code" href="../../dc/d41/class_n_b_connection.html#ad98eb5a1de393ce3a76c510efeb31756" title="returns the from-edge (start of the connection)">getFrom</a>() == 0 ||
<a name="l01105"></a>01105             mustStop.<a class="code" href="../../dc/d41/class_n_b_connection.html#a74ce42681b534f4095ae9ccdb3581542" title="returns the to-edge (end of the connection)">getTo</a>() == 0) {
<a name="l01106"></a>01106 
<a name="l01107"></a>01107         <a class="code" href="../../d4/df7/_msg_handler_8h.html#a6875e463bd2d24f027eba135e7a5fdfa">WRITE_WARNING</a>(<span class="stringliteral">&quot;Something went wrong during the building of a connection...&quot;</span>);
<a name="l01108"></a>01108         <span class="keywordflow">return</span>; <span class="comment">// !!! mark to recompute connections</span>
<a name="l01109"></a>01109     }
<a name="l01110"></a>01110     <a class="code" href="../../d4/d25/_n_b_connection_defs_8h.html#a5f0b6da942b048c8a727854f34530400" title="Definition of a connection vector.">NBConnectionVector</a> conn = <a class="code" href="../../d3/dd1/class_n_b_node.html#ac98d1cb79982c14acd078c3c5ad2df31">myBlockedConnections</a>[mustStop];
<a name="l01111"></a>01111     conn.push_back(mayDrive);
<a name="l01112"></a>01112     <a class="code" href="../../d3/dd1/class_n_b_node.html#ac98d1cb79982c14acd078c3c5ad2df31">myBlockedConnections</a>[mustStop] = conn;
<a name="l01113"></a>01113 }
<a name="l01114"></a>01114 
<a name="l01115"></a>01115 
<a name="l01116"></a>01116 <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>*
<a name="l01117"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#aee34c4e4949be6578a240f590f8d0902">01117</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#aee34c4e4949be6578a240f590f8d0902">NBNode::getPossiblySplittedIncoming</a>(<span class="keyword">const</span> std::string&amp; edgeid) {
<a name="l01118"></a>01118     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = (<span class="keywordtype">unsigned</span> int) edgeid.length();
<a name="l01119"></a>01119     <span class="keywordflow">for</span> (EdgeVector::iterator i = <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.begin(); i != <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.end(); i++) {
<a name="l01120"></a>01120         std::string <span class="keywordtype">id</span> = (*i)-&gt;<a class="code" href="../../d5/dbf/class_named.html#a20fd12b55c213fd79eae9fdd47b14eb1" title="Returns the id.">getID</a>();
<a name="l01121"></a>01121         <span class="keywordflow">if</span> (<span class="keywordtype">id</span>.substr(0, size) == edgeid) {
<a name="l01122"></a>01122             <span class="keywordflow">return</span> *i;
<a name="l01123"></a>01123         }
<a name="l01124"></a>01124     }
<a name="l01125"></a>01125     <span class="keywordflow">return</span> 0;
<a name="l01126"></a>01126 }
<a name="l01127"></a>01127 
<a name="l01128"></a>01128 
<a name="l01129"></a>01129 <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>*
<a name="l01130"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#aaa9eb2a16cea5bd73fee762b92cd5e93">01130</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#aaa9eb2a16cea5bd73fee762b92cd5e93">NBNode::getPossiblySplittedOutgoing</a>(<span class="keyword">const</span> std::string&amp; edgeid) {
<a name="l01131"></a>01131     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = (<span class="keywordtype">unsigned</span> int) edgeid.length();
<a name="l01132"></a>01132     <span class="keywordflow">for</span> (EdgeVector::iterator i = <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.begin(); i != <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.end(); i++) {
<a name="l01133"></a>01133         std::string <span class="keywordtype">id</span> = (*i)-&gt;<a class="code" href="../../d5/dbf/class_named.html#a20fd12b55c213fd79eae9fdd47b14eb1" title="Returns the id.">getID</a>();
<a name="l01134"></a>01134         <span class="keywordflow">if</span> (<span class="keywordtype">id</span>.substr(0, size) == edgeid) {
<a name="l01135"></a>01135             <span class="keywordflow">return</span> *i;
<a name="l01136"></a>01136         }
<a name="l01137"></a>01137     }
<a name="l01138"></a>01138     <span class="keywordflow">return</span> 0;
<a name="l01139"></a>01139 }
<a name="l01140"></a>01140 
<a name="l01141"></a>01141 
<a name="l01142"></a>01142 <span class="keywordtype">void</span>
<a name="l01143"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a0bdf9a0672639ad40b70a01fba3d1268">01143</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a0bdf9a0672639ad40b70a01fba3d1268" title="Removes edge from this node and optionally removes connections as well.">NBNode::removeEdge</a>(<a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* edge, <span class="keywordtype">bool</span> removeFromConnections) {
<a name="l01144"></a>01144     EdgeVector::iterator i = find(<a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.begin(), <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.end(), edge);
<a name="l01145"></a>01145     <span class="keywordflow">if</span> (i != <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.end()) {
<a name="l01146"></a>01146         <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.erase(i);
<a name="l01147"></a>01147         i = find(<a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.begin(), <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.end(), edge);
<a name="l01148"></a>01148         <span class="keywordflow">if</span> (i != <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.end()) {
<a name="l01149"></a>01149             <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.erase(i);
<a name="l01150"></a>01150         } <span class="keywordflow">else</span> {
<a name="l01151"></a>01151             i = find(<a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.begin(), <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.end(), edge);
<a name="l01152"></a>01152             <span class="keywordflow">if</span> (i != <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.end()) {
<a name="l01153"></a>01153                 <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.erase(i);
<a name="l01154"></a>01154             } <span class="keywordflow">else</span> {
<a name="l01155"></a>01155                 <span class="comment">// edge must have been either incoming or outgoing</span>
<a name="l01156"></a>01156                 assert(<span class="keyword">false</span>);
<a name="l01157"></a>01157             }
<a name="l01158"></a>01158         }
<a name="l01159"></a>01159         <span class="keywordflow">if</span> (removeFromConnections) {
<a name="l01160"></a>01160             <span class="keywordflow">for</span> (i = <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.begin(); i != <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.end(); ++i) {
<a name="l01161"></a>01161                 (*i)-&gt;removeFromConnections(edge);
<a name="l01162"></a>01162             }
<a name="l01163"></a>01163         }
<a name="l01164"></a>01164     }
<a name="l01165"></a>01165 }
<a name="l01166"></a>01166 
<a name="l01167"></a>01167 
<a name="l01168"></a>01168 <a class="code" href="../../d7/d3b/class_position.html" title="A point in 2D or 3D with translation and scaling methods.">Position</a>
<a name="l01169"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#aae31ba99f462c3500792e2a0222814ce">01169</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#aae31ba99f462c3500792e2a0222814ce" title="Returns something like the most unused direction Should only be used to add source...">NBNode::getEmptyDir</a>()<span class="keyword"> const </span>{
<a name="l01170"></a>01170     <a class="code" href="../../d7/d3b/class_position.html" title="A point in 2D or 3D with translation and scaling methods.">Position</a> pos(0, 0);
<a name="l01171"></a>01171     EdgeVector::const_iterator i;
<a name="l01172"></a>01172     <span class="keywordflow">for</span> (i = <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.begin(); i != <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.end(); i++) {
<a name="l01173"></a>01173         <a class="code" href="../../d3/dd1/class_n_b_node.html" title="Represents a single node (junction) during network building.">NBNode</a>* conn = (*i)-&gt;getFromNode();
<a name="l01174"></a>01174         <a class="code" href="../../d7/d3b/class_position.html" title="A point in 2D or 3D with translation and scaling methods.">Position</a> toAdd = conn-&gt;<a class="code" href="../../d3/dd1/class_n_b_node.html#a57c0891208c4e7b1925382169934b360" title="Returns the position of this node.">getPosition</a>();
<a name="l01175"></a>01175         toAdd.<a class="code" href="../../d7/d3b/class_position.html#a29103befbc903bc4d16ba9899cb49fbe" title="Substracts the given position from this one.">sub</a>(<a class="code" href="../../d3/dd1/class_n_b_node.html#aa2428b3f739977ceb4ac659eb93e4234" title="The position the node lies at.">myPosition</a>);
<a name="l01176"></a>01176         toAdd.<a class="code" href="../../d7/d3b/class_position.html#a58b8892ee65bcc05619d93f987cac82b" title="Multiplies both positions with the given value.">mul</a>((<a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a>) 1.0 / sqrt(toAdd.<a class="code" href="../../d7/d3b/class_position.html#a51c33a67d08730631a34482850b2203b" title="Returns the x-position.">x</a>()*toAdd.<a class="code" href="../../d7/d3b/class_position.html#a51c33a67d08730631a34482850b2203b" title="Returns the x-position.">x</a>() + toAdd.<a class="code" href="../../d7/d3b/class_position.html#a4a65556f1de2548b23ce662f81c7ab1a" title="Returns the y-position.">y</a>()*toAdd.<a class="code" href="../../d7/d3b/class_position.html#a4a65556f1de2548b23ce662f81c7ab1a" title="Returns the y-position.">y</a>()));
<a name="l01177"></a>01177         pos.<a class="code" href="../../d7/d3b/class_position.html#aa7f28af16b3c5e4396560db99d746389" title="Adds the given position to this one.">add</a>(toAdd);
<a name="l01178"></a>01178     }
<a name="l01179"></a>01179     <span class="keywordflow">for</span> (i = <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.begin(); i != <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.end(); i++) {
<a name="l01180"></a>01180         <a class="code" href="../../d3/dd1/class_n_b_node.html" title="Represents a single node (junction) during network building.">NBNode</a>* conn = (*i)-&gt;getToNode();
<a name="l01181"></a>01181         <a class="code" href="../../d7/d3b/class_position.html" title="A point in 2D or 3D with translation and scaling methods.">Position</a> toAdd = conn-&gt;<a class="code" href="../../d3/dd1/class_n_b_node.html#a57c0891208c4e7b1925382169934b360" title="Returns the position of this node.">getPosition</a>();
<a name="l01182"></a>01182         toAdd.<a class="code" href="../../d7/d3b/class_position.html#a29103befbc903bc4d16ba9899cb49fbe" title="Substracts the given position from this one.">sub</a>(<a class="code" href="../../d3/dd1/class_n_b_node.html#aa2428b3f739977ceb4ac659eb93e4234" title="The position the node lies at.">myPosition</a>);
<a name="l01183"></a>01183         toAdd.<a class="code" href="../../d7/d3b/class_position.html#a58b8892ee65bcc05619d93f987cac82b" title="Multiplies both positions with the given value.">mul</a>((<a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a>) 1.0 / sqrt(toAdd.<a class="code" href="../../d7/d3b/class_position.html#a51c33a67d08730631a34482850b2203b" title="Returns the x-position.">x</a>()*toAdd.<a class="code" href="../../d7/d3b/class_position.html#a51c33a67d08730631a34482850b2203b" title="Returns the x-position.">x</a>() + toAdd.<a class="code" href="../../d7/d3b/class_position.html#a4a65556f1de2548b23ce662f81c7ab1a" title="Returns the y-position.">y</a>()*toAdd.<a class="code" href="../../d7/d3b/class_position.html#a4a65556f1de2548b23ce662f81c7ab1a" title="Returns the y-position.">y</a>()));
<a name="l01184"></a>01184         pos.<a class="code" href="../../d7/d3b/class_position.html#aa7f28af16b3c5e4396560db99d746389" title="Adds the given position to this one.">add</a>(toAdd);
<a name="l01185"></a>01185     }
<a name="l01186"></a>01186     pos.<a class="code" href="../../d7/d3b/class_position.html#a58b8892ee65bcc05619d93f987cac82b" title="Multiplies both positions with the given value.">mul</a>((<a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a>) - 1.0 / (<a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.size() + <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.size()));
<a name="l01187"></a>01187     <span class="keywordflow">if</span> (pos.<a class="code" href="../../d7/d3b/class_position.html#a51c33a67d08730631a34482850b2203b" title="Returns the x-position.">x</a>() == 0 &amp;&amp; pos.<a class="code" href="../../d7/d3b/class_position.html#a4a65556f1de2548b23ce662f81c7ab1a" title="Returns the y-position.">y</a>() == 0) {
<a name="l01188"></a>01188         pos = <a class="code" href="../../d7/d3b/class_position.html" title="A point in 2D or 3D with translation and scaling methods.">Position</a>(1, 0);
<a name="l01189"></a>01189     }
<a name="l01190"></a>01190     pos.<a class="code" href="../../d7/d3b/class_position.html#a4db15e6cde50ad05b18ef906d2665460">norm2d</a>();
<a name="l01191"></a>01191     <span class="keywordflow">return</span> pos;
<a name="l01192"></a>01192 }
<a name="l01193"></a>01193 
<a name="l01194"></a>01194 
<a name="l01195"></a>01195 
<a name="l01196"></a>01196 <span class="keywordtype">void</span>
<a name="l01197"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a2b841926a812a6423654bd987d3d0a30">01197</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a2b841926a812a6423654bd987d3d0a30">NBNode::invalidateIncomingConnections</a>() {
<a name="l01198"></a>01198     <span class="keywordflow">for</span> (EdgeVector::const_iterator i = <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.begin(); i != <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.end(); i++) {
<a name="l01199"></a>01199         (*i)-&gt;invalidateConnections();
<a name="l01200"></a>01200     }
<a name="l01201"></a>01201 }
<a name="l01202"></a>01202 
<a name="l01203"></a>01203 
<a name="l01204"></a>01204 <span class="keywordtype">void</span>
<a name="l01205"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a53d44765cb8eb8f7b635d2db20010265">01205</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a53d44765cb8eb8f7b635d2db20010265">NBNode::invalidateOutgoingConnections</a>() {
<a name="l01206"></a>01206     <span class="keywordflow">for</span> (EdgeVector::const_iterator i = <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.begin(); i != <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.end(); i++) {
<a name="l01207"></a>01207         (*i)-&gt;invalidateConnections();
<a name="l01208"></a>01208     }
<a name="l01209"></a>01209 }
<a name="l01210"></a>01210 
<a name="l01211"></a>01211 
<a name="l01212"></a>01212 <span class="keywordtype">bool</span>
<a name="l01213"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a7c615b8ed5ba49be632dc68e825cca33">01213</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a7c615b8ed5ba49be632dc68e825cca33" title="Returns the information whether the described flow must let any other flow pass.">NBNode::mustBrake</a>(<span class="keyword">const</span> <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* <span class="keyword">const</span> from, <span class="keyword">const</span> <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* <span class="keyword">const</span> to, <span class="keywordtype">int</span> toLane)<span class="keyword"> const </span>{
<a name="l01214"></a>01214     <span class="comment">// check whether it is participant to a traffic light</span>
<a name="l01215"></a>01215     <span class="comment">//  - controlled links are set by the traffic lights, not the normal</span>
<a name="l01216"></a>01216     <span class="comment">//    right-of-way rules</span>
<a name="l01217"></a>01217     <span class="comment">//  - uncontrolled participants (spip lanes etc.) should always break</span>
<a name="l01218"></a>01218     <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#a7f77619f8b2c286410247b7dd4b4a23a">myTrafficLights</a>.size() != 0) {
<a name="l01219"></a>01219         <span class="comment">// ok, we have a traffic light, return true by now, it will be later</span>
<a name="l01220"></a>01220         <span class="comment">//  controlled by the tls</span>
<a name="l01221"></a>01221         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01222"></a>01222     }
<a name="l01223"></a>01223     <span class="comment">// unregulated-&gt;does not need to brake</span>
<a name="l01224"></a>01224     <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#a4db054c358db8eb749514219368f3308">myRequest</a> == 0) {
<a name="l01225"></a>01225         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01226"></a>01226     }
<a name="l01227"></a>01227     <span class="comment">// vehicles which do not have a following lane must always decelerate to the end</span>
<a name="l01228"></a>01228     <span class="keywordflow">if</span> (to == 0) {
<a name="l01229"></a>01229         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01230"></a>01230     }
<a name="l01231"></a>01231     <span class="comment">// check whether any other connection on this node prohibits this connection</span>
<a name="l01232"></a>01232     <span class="keywordtype">bool</span> try1 = <a class="code" href="../../d3/dd1/class_n_b_node.html#a4db054c358db8eb749514219368f3308">myRequest</a>-&gt;<a class="code" href="../../df/d8e/class_n_b_request.html#a663c6802da27e0469abe738079fb50ea" title="Returns the information whether &amp;quot;prohibited&amp;quot; flow must let &amp;quot;prohibitor&amp;quot;...">mustBrake</a>(from, to);
<a name="l01233"></a>01233     <span class="keywordflow">if</span> (!try1 || toLane == -1) {
<a name="l01234"></a>01234         <span class="keywordflow">return</span> try1;
<a name="l01235"></a>01235     }
<a name="l01236"></a>01236     <span class="keywordflow">if</span> (from-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#a6fa897ead9e371c1e431b8076550e74a" title="Returns the speed allowed on this edge.">getSpeed</a>() &lt; 70. / 3.6) {
<a name="l01237"></a>01237         <span class="keywordflow">return</span> try1;
<a name="l01238"></a>01238     }
<a name="l01239"></a>01239     <span class="comment">// on highways (on-ramps, in fact):</span>
<a name="l01240"></a>01240     <span class="comment">// check whether any other connection uses the same destination edge</span>
<a name="l01241"></a>01241     <span class="keywordflow">for</span> (EdgeVector::const_iterator i = <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.begin(); i != <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.end(); i++) {
<a name="l01242"></a>01242         <span class="keywordflow">if</span> ((*i) == from) {
<a name="l01243"></a>01243             <span class="keywordflow">continue</span>;
<a name="l01244"></a>01244         }
<a name="l01245"></a>01245         <span class="keyword">const</span> std::vector&lt;NBEdge::Connection&gt; &amp;connections = (*i)-&gt;getConnections();
<a name="l01246"></a>01246         <span class="keywordflow">for</span> (std::vector&lt;NBEdge::Connection&gt;::const_iterator j = connections.begin(); j != connections.end(); ++j) {
<a name="l01247"></a>01247             <span class="keywordflow">if</span> ((*j).toEdge == to &amp;&amp; ((*j).toLane &lt; 0 || (*j).toLane == toLane)) {
<a name="l01248"></a>01248                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01249"></a>01249             }
<a name="l01250"></a>01250         }
<a name="l01251"></a>01251     }
<a name="l01252"></a>01252     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01253"></a>01253 }
<a name="l01254"></a>01254 
<a name="l01255"></a>01255 
<a name="l01256"></a>01256 <span class="keywordtype">bool</span>
<a name="l01257"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a00ec1c56dfe07b2d268d7852007fcec2">01257</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a00ec1c56dfe07b2d268d7852007fcec2" title="Computes whether the given connection is a left mover across the junction.">NBNode::isLeftMover</a>(<span class="keyword">const</span> <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* <span class="keyword">const</span> from, <span class="keyword">const</span> <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* <span class="keyword">const</span> to)<span class="keyword"> const </span>{
<a name="l01258"></a>01258     <span class="comment">// when the junction has only one incoming edge, there are no</span>
<a name="l01259"></a>01259     <span class="comment">//  problems caused by left blockings</span>
<a name="l01260"></a>01260     <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.size() == 1 || <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.size() == 1) {
<a name="l01261"></a>01261         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01262"></a>01262     }
<a name="l01263"></a>01263     <a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a> fromAngle = from-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#a35a4bbaea9501ed0a2cd38a7f97b7086" title="Returns the angle of the edge.">getAngle</a>(*<span class="keyword">this</span>);
<a name="l01264"></a>01264     <a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a> toAngle = to-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#a35a4bbaea9501ed0a2cd38a7f97b7086" title="Returns the angle of the edge.">getAngle</a>(*<span class="keyword">this</span>);
<a name="l01265"></a>01265     <a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a> cw = <a class="code" href="../../d3/de6/class_geom_helper.html#aa66a4be03e23596f7d6539529b52a0a6" title="Returns the distance of second angle from first angle clockwise.">GeomHelper::getCWAngleDiff</a>(fromAngle, toAngle);
<a name="l01266"></a>01266     <a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a> ccw = <a class="code" href="../../d3/de6/class_geom_helper.html#a284494c179d675ac51b2593c1b2532ee" title="Returns the distance of second angle from first angle counter-clockwise.">GeomHelper::getCCWAngleDiff</a>(fromAngle, toAngle);
<a name="l01267"></a>01267     std::vector&lt;NBEdge*&gt;::const_iterator i = std::find(<a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.begin(), <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.end(), from);
<a name="l01268"></a>01268     <span class="keywordflow">do</span> {
<a name="l01269"></a>01269         <a class="code" href="../../df/d78/class_n_b_cont_helper.html#a27ff78c70d9a3f11b7dafd6f2bab51ee">NBContHelper::nextCW</a>(<a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>, i);
<a name="l01270"></a>01270     } <span class="keywordflow">while</span> ((!<a class="code" href="../../d3/dd1/class_n_b_node.html#a082d27c0dcdc09d2de15a04ccc0489d5" title="Returns whether the given edge starts at this node.">hasOutgoing</a>(*i) || from-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#a4acf76dc68775ec29767a43e95c907aa">getTurnDestination</a>() == *i) &amp;&amp; *i != from);
<a name="l01271"></a>01271     <span class="keywordflow">return</span> cw &lt; ccw &amp;&amp; (*i) == to &amp;&amp; <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.size() &gt; 2;
<a name="l01272"></a>01272 }
<a name="l01273"></a>01273 
<a name="l01274"></a>01274 
<a name="l01275"></a>01275 <span class="keywordtype">bool</span>
<a name="l01276"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#adb1a4ca8641b89e3a0e7d2e7b6b80e31">01276</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#adb1a4ca8641b89e3a0e7d2e7b6b80e31" title="Returns the information whether &amp;quot;prohibited&amp;quot; flow must let &amp;quot;prohibitor&amp;quot;...">NBNode::forbids</a>(<span class="keyword">const</span> <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* <span class="keyword">const</span> possProhibitorFrom, <span class="keyword">const</span> <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* <span class="keyword">const</span> possProhibitorTo,
<a name="l01277"></a>01277                 <span class="keyword">const</span> <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* <span class="keyword">const</span> possProhibitedFrom, <span class="keyword">const</span> <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* <span class="keyword">const</span> possProhibitedTo,
<a name="l01278"></a>01278                 <span class="keywordtype">bool</span> regardNonSignalisedLowerPriority)<span class="keyword"> const </span>{
<a name="l01279"></a>01279     <span class="keywordflow">return</span> <a class="code" href="../../d3/dd1/class_n_b_node.html#a4db054c358db8eb749514219368f3308">myRequest</a> != 0 &amp;&amp; <a class="code" href="../../d3/dd1/class_n_b_node.html#a4db054c358db8eb749514219368f3308">myRequest</a>-&gt;<a class="code" href="../../df/d8e/class_n_b_request.html#ad87face4381f34888e85ac299991cc3b" title="Returns the information whether &amp;quot;prohibited&amp;quot; flow must let &amp;quot;prohibitor&amp;quot;...">forbids</a>(possProhibitorFrom, possProhibitorTo,
<a name="l01280"></a>01280             possProhibitedFrom, possProhibitedTo,
<a name="l01281"></a>01281             regardNonSignalisedLowerPriority);
<a name="l01282"></a>01282 }
<a name="l01283"></a>01283 
<a name="l01284"></a>01284 
<a name="l01285"></a>01285 <span class="keywordtype">bool</span>
<a name="l01286"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a57da2da13804af5d849f61be6ee479cf">01286</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a57da2da13804af5d849f61be6ee479cf" title="Returns the information whether the given flows cross.">NBNode::foes</a>(<span class="keyword">const</span> <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* <span class="keyword">const</span> from1, <span class="keyword">const</span> <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* <span class="keyword">const</span> to1,
<a name="l01287"></a>01287              <span class="keyword">const</span> <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* <span class="keyword">const</span> from2, <span class="keyword">const</span> <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* <span class="keyword">const</span> to2)<span class="keyword"> const </span>{
<a name="l01288"></a>01288     <span class="keywordflow">return</span> <a class="code" href="../../d3/dd1/class_n_b_node.html#a4db054c358db8eb749514219368f3308">myRequest</a> != 0 &amp;&amp; <a class="code" href="../../d3/dd1/class_n_b_node.html#a4db054c358db8eb749514219368f3308">myRequest</a>-&gt;<a class="code" href="../../df/d8e/class_n_b_request.html#ac8e2a97cdb0880ab1773af3ff5cead6f" title="Returns the information whether the given flows cross.">foes</a>(from1, to1, from2, to2);
<a name="l01289"></a>01289 }
<a name="l01290"></a>01290 
<a name="l01291"></a>01291 
<a name="l01292"></a>01292 <span class="keywordtype">void</span>
<a name="l01293"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a446a4a767d46d16aaa463c74943ccb7a">01293</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a446a4a767d46d16aaa463c74943ccb7a">NBNode::remapRemoved</a>(<a class="code" href="../../d9/d5e/class_n_b_traffic_light_logic_cont.html" title="A container for traffic light definitions and built programs.">NBTrafficLightLogicCont</a>&amp; tc,
<a name="l01294"></a>01294                      <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* removed, <span class="keyword">const</span> <a class="code" href="../../db/dde/_n_b_cont_8h.html#a7bbd80497f8b27f18697210825ec974a">EdgeVector</a>&amp; incoming,
<a name="l01295"></a>01295                      <span class="keyword">const</span> <a class="code" href="../../db/dde/_n_b_cont_8h.html#a7bbd80497f8b27f18697210825ec974a">EdgeVector</a>&amp; outgoing) {
<a name="l01296"></a>01296     assert(find(incoming.begin(), incoming.end(), removed) == incoming.end());
<a name="l01297"></a>01297     <span class="keywordtype">bool</span> changed = <span class="keyword">true</span>;
<a name="l01298"></a>01298     <span class="keywordflow">while</span> (changed) {
<a name="l01299"></a>01299         changed = <span class="keyword">false</span>;
<a name="l01300"></a>01300         <a class="code" href="../../d4/d25/_n_b_connection_defs_8h.html#a433c47e38592c40c620bc22daeca98b1" title="Definition of a container for connection block dependencies Includes a list of all...">NBConnectionProhibits</a> blockedConnectionsTmp = <a class="code" href="../../d3/dd1/class_n_b_node.html#ac98d1cb79982c14acd078c3c5ad2df31">myBlockedConnections</a>;
<a name="l01301"></a>01301         <a class="code" href="../../d4/d25/_n_b_connection_defs_8h.html#a433c47e38592c40c620bc22daeca98b1" title="Definition of a container for connection block dependencies Includes a list of all...">NBConnectionProhibits</a> blockedConnectionsNew;
<a name="l01302"></a>01302         <span class="comment">// remap in connections</span>
<a name="l01303"></a>01303         <span class="keywordflow">for</span> (NBConnectionProhibits::iterator i = blockedConnectionsTmp.begin(); i != blockedConnectionsTmp.end(); i++) {
<a name="l01304"></a>01304             <span class="keyword">const</span> <a class="code" href="../../dc/d41/class_n_b_connection.html">NBConnection</a>&amp; blocker = (*i).first;
<a name="l01305"></a>01305             <span class="keyword">const</span> <a class="code" href="../../d4/d25/_n_b_connection_defs_8h.html#a5f0b6da942b048c8a727854f34530400" title="Definition of a connection vector.">NBConnectionVector</a>&amp; blocked = (*i).second;
<a name="l01306"></a>01306             <span class="comment">// check the blocked connections first</span>
<a name="l01307"></a>01307             <span class="comment">// check whether any of the blocked must be changed</span>
<a name="l01308"></a>01308             <span class="keywordtype">bool</span> blockedChanged = <span class="keyword">false</span>;
<a name="l01309"></a>01309             <a class="code" href="../../d4/d25/_n_b_connection_defs_8h.html#a5f0b6da942b048c8a727854f34530400" title="Definition of a connection vector.">NBConnectionVector</a> newBlocked;
<a name="l01310"></a>01310             NBConnectionVector::const_iterator j;
<a name="l01311"></a>01311             <span class="keywordflow">for</span> (j = blocked.begin(); j != blocked.end(); j++) {
<a name="l01312"></a>01312                 <span class="keyword">const</span> <a class="code" href="../../dc/d41/class_n_b_connection.html">NBConnection</a>&amp; sblocked = *j;
<a name="l01313"></a>01313                 <span class="keywordflow">if</span> (sblocked.<a class="code" href="../../dc/d41/class_n_b_connection.html#ad98eb5a1de393ce3a76c510efeb31756" title="returns the from-edge (start of the connection)">getFrom</a>() == removed || sblocked.<a class="code" href="../../dc/d41/class_n_b_connection.html#a74ce42681b534f4095ae9ccdb3581542" title="returns the to-edge (end of the connection)">getTo</a>() == removed) {
<a name="l01314"></a>01314                     blockedChanged = <span class="keyword">true</span>;
<a name="l01315"></a>01315                 }
<a name="l01316"></a>01316             }
<a name="l01317"></a>01317             <span class="comment">// adapt changes if so</span>
<a name="l01318"></a>01318             <span class="keywordflow">for</span> (j = blocked.begin(); blockedChanged &amp;&amp; j != blocked.end(); j++) {
<a name="l01319"></a>01319                 <span class="keyword">const</span> <a class="code" href="../../dc/d41/class_n_b_connection.html">NBConnection</a>&amp; sblocked = *j;
<a name="l01320"></a>01320                 <span class="keywordflow">if</span> (sblocked.<a class="code" href="../../dc/d41/class_n_b_connection.html#ad98eb5a1de393ce3a76c510efeb31756" title="returns the from-edge (start of the connection)">getFrom</a>() == removed &amp;&amp; sblocked.<a class="code" href="../../dc/d41/class_n_b_connection.html#a74ce42681b534f4095ae9ccdb3581542" title="returns the to-edge (end of the connection)">getTo</a>() == removed) {
<a name="l01321"></a>01321                     <span class="comment">/*                    for(EdgeVector::const_iterator k=incoming.begin(); k!=incoming.end(); k++) {</span>
<a name="l01322"></a>01322 <span class="comment">                    !!!                        newBlocked.push_back(NBConnection(*k, *k));</span>
<a name="l01323"></a>01323 <span class="comment">                                        }*/</span>
<a name="l01324"></a>01324                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sblocked.<a class="code" href="../../dc/d41/class_n_b_connection.html#ad98eb5a1de393ce3a76c510efeb31756" title="returns the from-edge (start of the connection)">getFrom</a>() == removed) {
<a name="l01325"></a>01325                     assert(sblocked.<a class="code" href="../../dc/d41/class_n_b_connection.html#a74ce42681b534f4095ae9ccdb3581542" title="returns the to-edge (end of the connection)">getTo</a>() != removed);
<a name="l01326"></a>01326                     <span class="keywordflow">for</span> (EdgeVector::const_iterator k = incoming.begin(); k != incoming.end(); k++) {
<a name="l01327"></a>01327                         newBlocked.push_back(<a class="code" href="../../dc/d41/class_n_b_connection.html">NBConnection</a>(*k, sblocked.<a class="code" href="../../dc/d41/class_n_b_connection.html#a74ce42681b534f4095ae9ccdb3581542" title="returns the to-edge (end of the connection)">getTo</a>()));
<a name="l01328"></a>01328                     }
<a name="l01329"></a>01329                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sblocked.<a class="code" href="../../dc/d41/class_n_b_connection.html#a74ce42681b534f4095ae9ccdb3581542" title="returns the to-edge (end of the connection)">getTo</a>() == removed) {
<a name="l01330"></a>01330                     assert(sblocked.<a class="code" href="../../dc/d41/class_n_b_connection.html#ad98eb5a1de393ce3a76c510efeb31756" title="returns the from-edge (start of the connection)">getFrom</a>() != removed);
<a name="l01331"></a>01331                     <span class="keywordflow">for</span> (EdgeVector::const_iterator k = outgoing.begin(); k != outgoing.end(); k++) {
<a name="l01332"></a>01332                         newBlocked.push_back(<a class="code" href="../../dc/d41/class_n_b_connection.html">NBConnection</a>(sblocked.<a class="code" href="../../dc/d41/class_n_b_connection.html#ad98eb5a1de393ce3a76c510efeb31756" title="returns the from-edge (start of the connection)">getFrom</a>(), *k));
<a name="l01333"></a>01333                     }
<a name="l01334"></a>01334                 } <span class="keywordflow">else</span> {
<a name="l01335"></a>01335                     newBlocked.push_back(<a class="code" href="../../dc/d41/class_n_b_connection.html">NBConnection</a>(sblocked.<a class="code" href="../../dc/d41/class_n_b_connection.html#ad98eb5a1de393ce3a76c510efeb31756" title="returns the from-edge (start of the connection)">getFrom</a>(), sblocked.<a class="code" href="../../dc/d41/class_n_b_connection.html#a74ce42681b534f4095ae9ccdb3581542" title="returns the to-edge (end of the connection)">getTo</a>()));
<a name="l01336"></a>01336                 }
<a name="l01337"></a>01337             }
<a name="l01338"></a>01338             <span class="keywordflow">if</span> (blockedChanged) {
<a name="l01339"></a>01339                 blockedConnectionsNew[blocker] = newBlocked;
<a name="l01340"></a>01340                 changed = <span class="keyword">true</span>;
<a name="l01341"></a>01341             }
<a name="l01342"></a>01342             <span class="comment">// if the blocked were kept</span>
<a name="l01343"></a>01343             <span class="keywordflow">else</span> {
<a name="l01344"></a>01344                 <span class="keywordflow">if</span> (blocker.<a class="code" href="../../dc/d41/class_n_b_connection.html#ad98eb5a1de393ce3a76c510efeb31756" title="returns the from-edge (start of the connection)">getFrom</a>() == removed &amp;&amp; blocker.<a class="code" href="../../dc/d41/class_n_b_connection.html#a74ce42681b534f4095ae9ccdb3581542" title="returns the to-edge (end of the connection)">getTo</a>() == removed) {
<a name="l01345"></a>01345                     changed = <span class="keyword">true</span>;
<a name="l01346"></a>01346                     <span class="comment">/*                    for(EdgeVector::const_iterator k=incoming.begin(); k!=incoming.end(); k++) {</span>
<a name="l01347"></a>01347 <span class="comment">                    !!!                        blockedConnectionsNew[NBConnection(*k, *k)] = blocked;</span>
<a name="l01348"></a>01348 <span class="comment">                                        }*/</span>
<a name="l01349"></a>01349                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (blocker.<a class="code" href="../../dc/d41/class_n_b_connection.html#ad98eb5a1de393ce3a76c510efeb31756" title="returns the from-edge (start of the connection)">getFrom</a>() == removed) {
<a name="l01350"></a>01350                     assert(blocker.<a class="code" href="../../dc/d41/class_n_b_connection.html#a74ce42681b534f4095ae9ccdb3581542" title="returns the to-edge (end of the connection)">getTo</a>() != removed);
<a name="l01351"></a>01351                     changed = <span class="keyword">true</span>;
<a name="l01352"></a>01352                     <span class="keywordflow">for</span> (EdgeVector::const_iterator k = incoming.begin(); k != incoming.end(); k++) {
<a name="l01353"></a>01353                         blockedConnectionsNew[<a class="code" href="../../dc/d41/class_n_b_connection.html">NBConnection</a>(*k, blocker.<a class="code" href="../../dc/d41/class_n_b_connection.html#a74ce42681b534f4095ae9ccdb3581542" title="returns the to-edge (end of the connection)">getTo</a>())] = blocked;
<a name="l01354"></a>01354                     }
<a name="l01355"></a>01355                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (blocker.<a class="code" href="../../dc/d41/class_n_b_connection.html#a74ce42681b534f4095ae9ccdb3581542" title="returns the to-edge (end of the connection)">getTo</a>() == removed) {
<a name="l01356"></a>01356                     assert(blocker.<a class="code" href="../../dc/d41/class_n_b_connection.html#ad98eb5a1de393ce3a76c510efeb31756" title="returns the from-edge (start of the connection)">getFrom</a>() != removed);
<a name="l01357"></a>01357                     changed = <span class="keyword">true</span>;
<a name="l01358"></a>01358                     <span class="keywordflow">for</span> (EdgeVector::const_iterator k = outgoing.begin(); k != outgoing.end(); k++) {
<a name="l01359"></a>01359                         blockedConnectionsNew[<a class="code" href="../../dc/d41/class_n_b_connection.html">NBConnection</a>(blocker.<a class="code" href="../../dc/d41/class_n_b_connection.html#ad98eb5a1de393ce3a76c510efeb31756" title="returns the from-edge (start of the connection)">getFrom</a>(), *k)] = blocked;
<a name="l01360"></a>01360                     }
<a name="l01361"></a>01361                 } <span class="keywordflow">else</span> {
<a name="l01362"></a>01362                     blockedConnectionsNew[blocker] = blocked;
<a name="l01363"></a>01363                 }
<a name="l01364"></a>01364             }
<a name="l01365"></a>01365         }
<a name="l01366"></a>01366         <a class="code" href="../../d3/dd1/class_n_b_node.html#ac98d1cb79982c14acd078c3c5ad2df31">myBlockedConnections</a> = blockedConnectionsNew;
<a name="l01367"></a>01367     }
<a name="l01368"></a>01368     <span class="comment">// remap in traffic lights</span>
<a name="l01369"></a>01369     tc.<a class="code" href="../../d9/d5e/class_n_b_traffic_light_logic_cont.html#a9ecd07927dcd01414437cc9c1f414f04" title="Replaces occurences of the removed edge in incoming/outgoing edges of all definitions...">remapRemoved</a>(removed, incoming, outgoing);
<a name="l01370"></a>01370 }
<a name="l01371"></a>01371 
<a name="l01372"></a>01372 
<a name="l01373"></a>01373 <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#aa0b67dafb51a20429fabfa8d7a07d57e" title="The different directions a link between two lanes may take (or a stream between two...">LinkDirection</a>
<a name="l01374"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a01b253c12dd598c6f9a7dbae85c3bab9">01374</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a01b253c12dd598c6f9a7dbae85c3bab9" title="Returns the representation of the described stream&amp;#39;s direction.">NBNode::getDirection</a>(<span class="keyword">const</span> <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* <span class="keyword">const</span> incoming, <span class="keyword">const</span> <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* <span class="keyword">const</span> outgoing)<span class="keyword"> const </span>{
<a name="l01375"></a>01375     <span class="comment">// ok, no connection at all -&gt; dead end</span>
<a name="l01376"></a>01376     <span class="keywordflow">if</span> (outgoing == 0) {
<a name="l01377"></a>01377         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#aa0b67dafb51a20429fabfa8d7a07d57ea2d91161a4acb5b57b46a98ee0fd03cee" title="The link has no direction (is a dead end link).">LINKDIR_NODIR</a>;
<a name="l01378"></a>01378     }
<a name="l01379"></a>01379     <span class="comment">// turning direction</span>
<a name="l01380"></a>01380     <span class="keywordflow">if</span> (incoming-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#a524ad2f68eea68fb66ae185949a3a379" title="Returns whether the given edge is the opposite direction to this edge.">isTurningDirectionAt</a>(<span class="keyword">this</span>, outgoing)) {
<a name="l01381"></a>01381         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#aa0b67dafb51a20429fabfa8d7a07d57ea3a971c67f9867b2541430659aa19d9f9" title="The link is a 180 degree turn.">LINKDIR_TURN</a>;
<a name="l01382"></a>01382     }
<a name="l01383"></a>01383     <span class="comment">// get the angle between incoming/outgoing at the junction</span>
<a name="l01384"></a>01384     <a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a> angle =
<a name="l01385"></a>01385         <a class="code" href="../../d5/d33/class_n_b_helpers.html#a13b9e92812d372d8da6ebb00a4d5c4bd">NBHelpers::normRelAngle</a>(incoming-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#a35a4bbaea9501ed0a2cd38a7f97b7086" title="Returns the angle of the edge.">getAngle</a>(*<span class="keyword">this</span>), outgoing-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#a35a4bbaea9501ed0a2cd38a7f97b7086" title="Returns the angle of the edge.">getAngle</a>(*<span class="keyword">this</span>));
<a name="l01386"></a>01386     <span class="comment">// ok, should be a straight connection</span>
<a name="l01387"></a>01387     <span class="keywordflow">if</span> (<a class="code" href="../../d1/dc9/polyfonts_8c.html#a6a010865b10e541735fa2da8f3cd062d">abs</a>((<span class="keywordtype">int</span>) angle) + 1 &lt; 45) {
<a name="l01388"></a>01388         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#aa0b67dafb51a20429fabfa8d7a07d57eabc27441c2a3b10f8f91081a9e4d6575c" title="The link is a straight direction.">LINKDIR_STRAIGHT</a>;
<a name="l01389"></a>01389     }
<a name="l01390"></a>01390 
<a name="l01391"></a>01391     <span class="comment">// check for left and right, first</span>
<a name="l01392"></a>01392     <span class="keywordflow">if</span> (angle &gt; 0) {
<a name="l01393"></a>01393         <span class="comment">// check whether any other edge goes further to the right</span>
<a name="l01394"></a>01394         EdgeVector::const_iterator i =
<a name="l01395"></a>01395             find(<a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.begin(), <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.end(), outgoing);
<a name="l01396"></a>01396         <a class="code" href="../../df/d78/class_n_b_cont_helper.html#a27ff78c70d9a3f11b7dafd6f2bab51ee">NBContHelper::nextCW</a>(<a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>, i);
<a name="l01397"></a>01397         <span class="keywordflow">while</span> ((*i) != incoming) {
<a name="l01398"></a>01398             <span class="keywordflow">if</span> ((*i)-&gt;getFromNode() == <span class="keyword">this</span>) {
<a name="l01399"></a>01399                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#aa0b67dafb51a20429fabfa8d7a07d57eadd6b539ec90b1d119e9d8f4097a0c35b" title="The link is a partial right direction.">LINKDIR_PARTRIGHT</a>;
<a name="l01400"></a>01400             }
<a name="l01401"></a>01401             NBContHelper::nextCW(<a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>, i);
<a name="l01402"></a>01402         }
<a name="l01403"></a>01403         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#aa0b67dafb51a20429fabfa8d7a07d57ea049aa1a1a8489768120ecb4bb76c0d1f" title="The link is a (hard) right direction.">LINKDIR_RIGHT</a>;
<a name="l01404"></a>01404     }
<a name="l01405"></a>01405     <span class="comment">// check whether any other edge goes further to the left</span>
<a name="l01406"></a>01406     EdgeVector::const_iterator i =
<a name="l01407"></a>01407         find(<a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.begin(), <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.end(), outgoing);
<a name="l01408"></a>01408     <a class="code" href="../../df/d78/class_n_b_cont_helper.html#a21138d0a8acaa32b2179acff29555d10">NBContHelper::nextCCW</a>(<a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>, i);
<a name="l01409"></a>01409     <span class="keywordflow">while</span> ((*i) != incoming) {
<a name="l01410"></a>01410         <span class="keywordflow">if</span> ((*i)-&gt;getFromNode() == <span class="keyword">this</span> &amp;&amp; !incoming-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#a524ad2f68eea68fb66ae185949a3a379" title="Returns whether the given edge is the opposite direction to this edge.">isTurningDirectionAt</a>(<span class="keyword">this</span>, *i)) {
<a name="l01411"></a>01411             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#aa0b67dafb51a20429fabfa8d7a07d57ea752d5f231f4dacc62853855ce88f909c" title="The link is a partial left direction.">LINKDIR_PARTLEFT</a>;
<a name="l01412"></a>01412         }
<a name="l01413"></a>01413         NBContHelper::nextCCW(<a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>, i);
<a name="l01414"></a>01414     }
<a name="l01415"></a>01415     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#aa0b67dafb51a20429fabfa8d7a07d57eaad7740c4bcacf58c61c9b78b459a9b58" title="The link is a (hard) left direction.">LINKDIR_LEFT</a>;
<a name="l01416"></a>01416 }
<a name="l01417"></a>01417 
<a name="l01418"></a>01418 
<a name="l01419"></a>01419 std::string
<a name="l01420"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a20ab552b6897dd1b3ac9a39bdc5f7602">01420</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a20ab552b6897dd1b3ac9a39bdc5f7602">NBNode::stateCode</a>(<span class="keyword">const</span> <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* incoming, <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* outgoing, <span class="keywordtype">int</span> fromlane, <span class="keywordtype">bool</span> mayDefinitelyPass)<span class="keyword"> const </span>{
<a name="l01421"></a>01421     <span class="keywordflow">if</span> (outgoing == 0) { <span class="comment">// always off</span>
<a name="l01422"></a>01422         <span class="keywordflow">return</span> <a class="code" href="../../d8/d08/_to_string_8h.html#a18065e342d6bcbee25664108f38176f9">toString</a>(<a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#ab0033b911037fd995258d117e65461e0aff6df2b3d76bd175d3c5c8427cb27eef" title="The link is controlled by a tls which is off, not blinking, may pass.">LINKSTATE_TL_OFF_NOSIGNAL</a>);
<a name="l01423"></a>01423     }
<a name="l01424"></a>01424     <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#a4547c21e970c3ca1cdf98d20c347ffdc" title="The type of the junction.">myType</a> == <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#ab28dfb39f850f0859f8e28940b7ff60ba3ab04e8411b56a12f844bd542e004e73">NODETYPE_RIGHT_BEFORE_LEFT</a>) {
<a name="l01425"></a>01425         <span class="keywordflow">return</span> <a class="code" href="../../d8/d08/_to_string_8h.html#a18065e342d6bcbee25664108f38176f9">toString</a>(<a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#ab0033b911037fd995258d117e65461e0a6defec283ab1a09233513987b79422bd" title="This is an uncontrolled, right-before-left link.">LINKSTATE_EQUAL</a>); <span class="comment">// all the same</span>
<a name="l01426"></a>01426     }
<a name="l01427"></a>01427     <span class="keywordflow">if</span> ((!incoming-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#a2a58ca53216792958506039a4b79c77f" title="Returns whether this edge was marked as being within an intersection.">isInnerEdge</a>() &amp;&amp; <a class="code" href="../../d3/dd1/class_n_b_node.html#a7c615b8ed5ba49be632dc68e825cca33" title="Returns the information whether the described flow must let any other flow pass.">mustBrake</a>(incoming, outgoing, fromlane)) &amp;&amp; !mayDefinitelyPass) {
<a name="l01428"></a>01428         <span class="keywordflow">return</span> <a class="code" href="../../d8/d08/_to_string_8h.html#a18065e342d6bcbee25664108f38176f9">toString</a>(<a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#ab0033b911037fd995258d117e65461e0ae0d93cfcc0717676c3c507391e8e1454" title="This is an uncontrolled, minor link, has to brake.">LINKSTATE_MINOR</a>); <span class="comment">// minor road</span>
<a name="l01429"></a>01429     }
<a name="l01430"></a>01430     <span class="comment">// traffic lights are not regardedm here</span>
<a name="l01431"></a>01431     <span class="keywordflow">return</span> <a class="code" href="../../d8/d08/_to_string_8h.html#a18065e342d6bcbee25664108f38176f9">toString</a>(<a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#ab0033b911037fd995258d117e65461e0a1d4f805b7978c331d04f79c7ae6f9fe4" title="This is an uncontrolled, major link, may pass.">LINKSTATE_MAJOR</a>);
<a name="l01432"></a>01432 }
<a name="l01433"></a>01433 
<a name="l01434"></a>01434 
<a name="l01435"></a>01435 <span class="keywordtype">bool</span>
<a name="l01436"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a10c5858530c9b6ef5c23625d00160c20">01436</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a10c5858530c9b6ef5c23625d00160c20">NBNode::checkIsRemovable</a>()<span class="keyword"> const </span>{
<a name="l01437"></a>01437     <span class="comment">// check whether this node is included in a traffic light</span>
<a name="l01438"></a>01438     <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#a7f77619f8b2c286410247b7dd4b4a23a">myTrafficLights</a>.size() != 0) {
<a name="l01439"></a>01439         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01440"></a>01440     }
<a name="l01441"></a>01441     EdgeVector::const_iterator i;
<a name="l01442"></a>01442     <span class="comment">// one in, one out -&gt; just a geometry ...</span>
<a name="l01443"></a>01443     <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.size() == 1 &amp;&amp; <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.size() == 1) {
<a name="l01444"></a>01444         <span class="comment">// ... if types match ...</span>
<a name="l01445"></a>01445         <span class="keywordflow">if</span> (!<a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>[0]-&gt;expandableBy(<a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>[0])) {
<a name="l01446"></a>01446             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01447"></a>01447         }
<a name="l01448"></a>01448         <span class="comment">//</span>
<a name="l01449"></a>01449         <span class="keywordflow">return</span> <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>[0]-&gt;getFromNode() != <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>[0]-&gt;getToNode();
<a name="l01450"></a>01450     }
<a name="l01451"></a>01451     <span class="comment">// two in, two out -&gt; may be something else</span>
<a name="l01452"></a>01452     <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.size() == 2 &amp;&amp; <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.size() == 2) {
<a name="l01453"></a>01453         <span class="comment">// check whether the origin nodes of the incoming edges differ</span>
<a name="l01454"></a>01454         std::set&lt;NBNode*&gt; origSet;
<a name="l01455"></a>01455         <span class="keywordflow">for</span> (i = <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.begin(); i != <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.end(); i++) {
<a name="l01456"></a>01456             origSet.insert((*i)-&gt;getFromNode());
<a name="l01457"></a>01457         }
<a name="l01458"></a>01458         <span class="keywordflow">if</span> (origSet.size() &lt; 2) {
<a name="l01459"></a>01459             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01460"></a>01460         }
<a name="l01461"></a>01461         <span class="comment">// check whether this node is an intermediate node of</span>
<a name="l01462"></a>01462         <span class="comment">//  a two-directional street</span>
<a name="l01463"></a>01463         <span class="keywordflow">for</span> (i = <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.begin(); i != <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.end(); i++) {
<a name="l01464"></a>01464             <span class="comment">// try to find the opposite direction</span>
<a name="l01465"></a>01465             <a class="code" href="../../d3/dd1/class_n_b_node.html" title="Represents a single node (junction) during network building.">NBNode</a>* origin = (*i)-&gt;getFromNode();
<a name="l01466"></a>01466             <span class="comment">// find the back direction of the current edge</span>
<a name="l01467"></a>01467             EdgeVector::const_iterator j =
<a name="l01468"></a>01468                 find_if(<a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.begin(), <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.end(),
<a name="l01469"></a>01469                         <a class="code" href="../../d7/d26/class_n_b_cont_helper_1_1edge__with__destination__finder.html">NBContHelper::edge_with_destination_finder</a>(origin));
<a name="l01470"></a>01470             <span class="comment">// check whether the back direction exists</span>
<a name="l01471"></a>01471             <span class="keywordflow">if</span> (j != <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.end()) {
<a name="l01472"></a>01472                 <span class="comment">// check whether the edge from the backdirection (must be</span>
<a name="l01473"></a>01473                 <span class="comment">//  the counter-clockwise one) may be joined with the current</span>
<a name="l01474"></a>01474                 <a class="code" href="../../df/d78/class_n_b_cont_helper.html#a21138d0a8acaa32b2179acff29555d10">NBContHelper::nextCCW</a>(<a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>, j);
<a name="l01475"></a>01475                 <span class="comment">// check whether the types allow joining</span>
<a name="l01476"></a>01476                 <span class="keywordflow">if</span> (!(*i)-&gt;expandableBy(*j)) {
<a name="l01477"></a>01477                     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01478"></a>01478                 }
<a name="l01479"></a>01479             } <span class="keywordflow">else</span> {
<a name="l01480"></a>01480                 <span class="comment">// ok, at least one outgoing edge is not an opposite</span>
<a name="l01481"></a>01481                 <span class="comment">//  of an incoming one</span>
<a name="l01482"></a>01482                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01483"></a>01483             }
<a name="l01484"></a>01484         }
<a name="l01485"></a>01485         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01486"></a>01486     }
<a name="l01487"></a>01487     <span class="comment">// ok, a real node</span>
<a name="l01488"></a>01488     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01489"></a>01489 }
<a name="l01490"></a>01490 
<a name="l01491"></a>01491 
<a name="l01492"></a>01492 std::vector&lt;std::pair&lt;NBEdge*, NBEdge*&gt; &gt;
<a name="l01493"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a8adf5404c80118f5327efaf32994f265">01493</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a8adf5404c80118f5327efaf32994f265">NBNode::getEdgesToJoin</a>()<span class="keyword"> const </span>{
<a name="l01494"></a>01494     assert(<a class="code" href="../../d3/dd1/class_n_b_node.html#a10c5858530c9b6ef5c23625d00160c20">checkIsRemovable</a>());
<a name="l01495"></a>01495     std::vector&lt;std::pair&lt;NBEdge*, NBEdge*&gt; &gt; ret;
<a name="l01496"></a>01496     <span class="comment">// one in, one out-case</span>
<a name="l01497"></a>01497     <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.size() == 1 &amp;&amp; <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.size() == 1) {
<a name="l01498"></a>01498         ret.push_back(
<a name="l01499"></a>01499             std::pair&lt;NBEdge*, NBEdge*&gt;(
<a name="l01500"></a>01500                 <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>[0], <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>[0]));
<a name="l01501"></a>01501         <span class="keywordflow">return</span> ret;
<a name="l01502"></a>01502     }
<a name="l01503"></a>01503     <span class="comment">// two in, two out-case</span>
<a name="l01504"></a>01504     <span class="keywordflow">for</span> (EdgeVector::const_iterator i = <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.begin(); i != <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.end(); i++) {
<a name="l01505"></a>01505         <a class="code" href="../../d3/dd1/class_n_b_node.html" title="Represents a single node (junction) during network building.">NBNode</a>* origin = (*i)-&gt;getFromNode();
<a name="l01506"></a>01506         EdgeVector::const_iterator j =
<a name="l01507"></a>01507             find_if(<a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.begin(), <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.end(),
<a name="l01508"></a>01508                     <a class="code" href="../../d7/d26/class_n_b_cont_helper_1_1edge__with__destination__finder.html">NBContHelper::edge_with_destination_finder</a>(origin));
<a name="l01509"></a>01509         <a class="code" href="../../df/d78/class_n_b_cont_helper.html#a21138d0a8acaa32b2179acff29555d10">NBContHelper::nextCCW</a>(<a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>, j);
<a name="l01510"></a>01510         ret.push_back(std::pair&lt;NBEdge*, NBEdge*&gt;(*i, *j));
<a name="l01511"></a>01511     }
<a name="l01512"></a>01512     <span class="keywordflow">return</span> ret;
<a name="l01513"></a>01513 }
<a name="l01514"></a>01514 
<a name="l01515"></a>01515 
<a name="l01516"></a>01516 <span class="keyword">const</span> <a class="code" href="../../da/d56/class_position_vector.html" title="A list of 2D-positions.">PositionVector</a>&amp;
<a name="l01517"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a6f8f85f458169473d0e8e5146a1643d6">01517</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a6f8f85f458169473d0e8e5146a1643d6">NBNode::getShape</a>()<span class="keyword"> const </span>{
<a name="l01518"></a>01518     <span class="keywordflow">return</span> <a class="code" href="../../d3/dd1/class_n_b_node.html#ae698ead9f7c0e5205646ebec2839c8bc" title="the (outer) shape of the junction">myPoly</a>;
<a name="l01519"></a>01519 }
<a name="l01520"></a>01520 
<a name="l01521"></a>01521 
<a name="l01522"></a>01522 <a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a>
<a name="l01523"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a0092838c42051b46dc318af17e7054a1">01523</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a0092838c42051b46dc318af17e7054a1">NBNode::getMaxEdgeWidth</a>()<span class="keyword"> const </span>{
<a name="l01524"></a>01524     EdgeVector::const_iterator i = <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.begin();
<a name="l01525"></a>01525     assert(i != <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.end());
<a name="l01526"></a>01526     <a class="code" href="../../db/d16/config_8h.html#a2481f526aef497857d2b407bc09129fd">SUMOReal</a> ret = (*i)-&gt;width();
<a name="l01527"></a>01527     ++i;
<a name="l01528"></a>01528     <span class="keywordflow">for</span> (; i != <a class="code" href="../../d3/dd1/class_n_b_node.html#a748c59ba687955ae903aa67a1258bd44" title="Vector of incoming and outgoing edges.">myAllEdges</a>.end(); i++) {
<a name="l01529"></a>01529         ret = ret &gt; (*i)-&gt;width() ? ret : (*i)-&gt;width();
<a name="l01530"></a>01530     }
<a name="l01531"></a>01531     <span class="keywordflow">return</span> ret;
<a name="l01532"></a>01532 }
<a name="l01533"></a>01533 
<a name="l01534"></a>01534 
<a name="l01535"></a>01535 <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>*
<a name="l01536"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a8dbe9de053a4e9097a4afb7c719b2387">01536</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a8dbe9de053a4e9097a4afb7c719b2387">NBNode::getConnectionTo</a>(<a class="code" href="../../d3/dd1/class_n_b_node.html" title="Represents a single node (junction) during network building.">NBNode</a>* n)<span class="keyword"> const </span>{
<a name="l01537"></a>01537     <span class="keywordflow">for</span> (EdgeVector::const_iterator i = <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.begin(); i != <a class="code" href="../../d3/dd1/class_n_b_node.html#a46ffcabf50248d642fdb32432e9d76a7" title="Vector of outgoing edges.">myOutgoingEdges</a>.end(); i++) {
<a name="l01538"></a>01538         <span class="keywordflow">if</span> ((*i)-&gt;getToNode() == n) {
<a name="l01539"></a>01539             <span class="keywordflow">return</span> (*i);
<a name="l01540"></a>01540         }
<a name="l01541"></a>01541     }
<a name="l01542"></a>01542     <span class="keywordflow">return</span> 0;
<a name="l01543"></a>01543 }
<a name="l01544"></a>01544 
<a name="l01545"></a>01545 
<a name="l01546"></a>01546 <span class="keywordtype">bool</span>
<a name="l01547"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a02dd480f3582912cb466098ebc60f8f2">01547</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a02dd480f3582912cb466098ebc60f8f2">NBNode::isNearDistrict</a>()<span class="keyword"> const </span>{
<a name="l01548"></a>01548     <span class="keywordflow">if</span> (<a class="code" href="../../d3/dd1/class_n_b_node.html#a578a65d1b86e9b9b45aa53e6132b93fa">isDistrict</a>()) {
<a name="l01549"></a>01549         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01550"></a>01550     }
<a name="l01551"></a>01551     <a class="code" href="../../db/dde/_n_b_cont_8h.html#a7bbd80497f8b27f18697210825ec974a">EdgeVector</a> edges;
<a name="l01552"></a>01552     copy(<a class="code" href="../../d3/dd1/class_n_b_node.html#a8528083710540004a765fc56643c9562" title="Returns this node&amp;#39;s incoming edges.">getIncomingEdges</a>().begin(), <a class="code" href="../../d3/dd1/class_n_b_node.html#a8528083710540004a765fc56643c9562" title="Returns this node&amp;#39;s incoming edges.">getIncomingEdges</a>().end(),
<a name="l01553"></a>01553          back_inserter(edges));
<a name="l01554"></a>01554     copy(<a class="code" href="../../d3/dd1/class_n_b_node.html#a7e586b529f4d8c758716a8c72220ca38" title="Returns this node&amp;#39;s outgoing edges.">getOutgoingEdges</a>().begin(), <a class="code" href="../../d3/dd1/class_n_b_node.html#a7e586b529f4d8c758716a8c72220ca38" title="Returns this node&amp;#39;s outgoing edges.">getOutgoingEdges</a>().end(),
<a name="l01555"></a>01555          back_inserter(edges));
<a name="l01556"></a>01556     <span class="keywordflow">for</span> (EdgeVector::const_iterator j = edges.begin(); j != edges.end(); ++j) {
<a name="l01557"></a>01557         <a class="code" href="../../d7/d41/class_n_b_edge.html" title="The representation of a single edge during network building.">NBEdge</a>* t = *j;
<a name="l01558"></a>01558         <a class="code" href="../../d3/dd1/class_n_b_node.html" title="Represents a single node (junction) during network building.">NBNode</a>* other = 0;
<a name="l01559"></a>01559         <span class="keywordflow">if</span> (t-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#a47de8fb27ded13ba7886218da6b9a60f" title="Returns the destination node of the edge.">getToNode</a>() == <span class="keyword">this</span>) {
<a name="l01560"></a>01560             other = t-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#ab279b96c38a10b1aafba2b8f736b0410" title="Returns the origin node of the edge.">getFromNode</a>();
<a name="l01561"></a>01561         } <span class="keywordflow">else</span> {
<a name="l01562"></a>01562             other = t-&gt;<a class="code" href="../../d7/d41/class_n_b_edge.html#a47de8fb27ded13ba7886218da6b9a60f" title="Returns the destination node of the edge.">getToNode</a>();
<a name="l01563"></a>01563         }
<a name="l01564"></a>01564         <a class="code" href="../../db/dde/_n_b_cont_8h.html#a7bbd80497f8b27f18697210825ec974a">EdgeVector</a> edges2;
<a name="l01565"></a>01565         copy(other-&gt;<a class="code" href="../../d3/dd1/class_n_b_node.html#a8528083710540004a765fc56643c9562" title="Returns this node&amp;#39;s incoming edges.">getIncomingEdges</a>().begin(), other-&gt;<a class="code" href="../../d3/dd1/class_n_b_node.html#a8528083710540004a765fc56643c9562" title="Returns this node&amp;#39;s incoming edges.">getIncomingEdges</a>().end(), back_inserter(edges2));
<a name="l01566"></a>01566         copy(other-&gt;<a class="code" href="../../d3/dd1/class_n_b_node.html#a7e586b529f4d8c758716a8c72220ca38" title="Returns this node&amp;#39;s outgoing edges.">getOutgoingEdges</a>().begin(), other-&gt;<a class="code" href="../../d3/dd1/class_n_b_node.html#a7e586b529f4d8c758716a8c72220ca38" title="Returns this node&amp;#39;s outgoing edges.">getOutgoingEdges</a>().end(), back_inserter(edges2));
<a name="l01567"></a>01567         <span class="keywordflow">for</span> (EdgeVector::const_iterator k = edges2.begin(); k != edges2.end(); ++k) {
<a name="l01568"></a>01568             <span class="keywordflow">if</span> ((*k)-&gt;getFromNode()-&gt;isDistrict() || (*k)-&gt;getToNode()-&gt;isDistrict()) {
<a name="l01569"></a>01569                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01570"></a>01570             }
<a name="l01571"></a>01571         }
<a name="l01572"></a>01572     }
<a name="l01573"></a>01573     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01574"></a>01574 }
<a name="l01575"></a>01575 
<a name="l01576"></a>01576 
<a name="l01577"></a>01577 <span class="keywordtype">bool</span>
<a name="l01578"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a578a65d1b86e9b9b45aa53e6132b93fa">01578</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a578a65d1b86e9b9b45aa53e6132b93fa">NBNode::isDistrict</a>()<span class="keyword"> const </span>{
<a name="l01579"></a>01579     <span class="keywordflow">return</span> <a class="code" href="../../d3/dd1/class_n_b_node.html#a4547c21e970c3ca1cdf98d20c347ffdc" title="The type of the junction.">myType</a> == <a class="code" href="../../d6/d7a/_s_u_m_o_x_m_l_definitions_8h.html#ab28dfb39f850f0859f8e28940b7ff60bad47669f635d721ff836d08b870a9efc4">NODETYPE_DISTRICT</a>;
<a name="l01580"></a>01580 }
<a name="l01581"></a>01581 
<a name="l01582"></a>01582 
<a name="l01583"></a>01583 <span class="keywordtype">void</span>
<a name="l01584"></a><a class="code" href="../../d3/dd1/class_n_b_node.html#a0bf354a956a31d0ca182ff7b7ad21d07">01584</a> <a class="code" href="../../d3/dd1/class_n_b_node.html#a0bf354a956a31d0ca182ff7b7ad21d07">NBNode::buildInnerEdges</a>() {
<a name="l01585"></a>01585     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> noInternalNoSplits = 0;
<a name="l01586"></a>01586     <span class="keywordflow">for</span> (EdgeVector::const_iterator i = <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.begin(); i != <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.end(); i++) {
<a name="l01587"></a>01587         <span class="keyword">const</span> std::vector&lt;NBEdge::Connection&gt; &amp;elv = (*i)-&gt;getConnections();
<a name="l01588"></a>01588         <span class="keywordflow">for</span> (std::vector&lt;NBEdge::Connection&gt;::const_iterator k = elv.begin(); k != elv.end(); ++k) {
<a name="l01589"></a>01589             <span class="keywordflow">if</span> ((*k).toEdge == 0) {
<a name="l01590"></a>01590                 <span class="keywordflow">continue</span>;
<a name="l01591"></a>01591             }
<a name="l01592"></a>01592             noInternalNoSplits++;
<a name="l01593"></a>01593         }
<a name="l01594"></a>01594     }
<a name="l01595"></a>01595     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lno = 0;
<a name="l01596"></a>01596     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> splitNo = 0;
<a name="l01597"></a>01597     <span class="keywordflow">for</span> (EdgeVector::const_iterator i = <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.begin(); i != <a class="code" href="../../d3/dd1/class_n_b_node.html#af1e07893cff580ef9a4532eed97046f3" title="Vector of incoming edges.">myIncomingEdges</a>.end(); i++) {
<a name="l01598"></a>01598         (*i)-&gt;buildInnerEdges(*<span class="keyword">this</span>, noInternalNoSplits, lno, splitNo);
<a name="l01599"></a>01599     }
<a name="l01600"></a>01600 }
<a name="l01601"></a>01601 
<a name="l01602"></a>01602 
<a name="l01603"></a>01603 <span class="comment">/****************************************************************************/</span>
<a name="l01604"></a>01604 
</pre></div></div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Tue Jul 17 12:16:03 2012 for SUMO - Simulation of Urban MObility by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
